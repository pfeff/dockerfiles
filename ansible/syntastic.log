SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
Sourced 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_autoloclist = 1
                            
    1              0.000004 let g:SyntasticAutoloclistNotifier = {}
                            
                            " Public methods {{{1
                            "
    1              0.000004 function! g:SyntasticAutoloclistNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000004 function! g:SyntasticAutoloclistNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
                                call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
                                if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
                                    if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
                                        lclose
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/balloons.vim
Sourced 2 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_balloons = 1
                            
    1              0.000005 if !has('balloon_eval')
    1              0.000003     let g:syntastic_enable_balloons = 0
    1              0.000001 endif
                            
    1              0.000003 let g:SyntasticBalloonsNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticBalloonsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticBalloonsNotifier.enabled() abort " {{{2
                                return has('balloon_eval') && syntastic#util#var('enable_balloons')
                            endfunction " }}}2
                            
                            " Update the error balloons
    1              0.000003 function! g:SyntasticBalloonsNotifier.refresh(loclist) abort " {{{2
                                unlet! b:syntastic_private_balloons
                                if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " Reset the error balloons
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000003 function! g:SyntasticBalloonsNotifier.reset(loclist) abort " {{{2
                                let b:syntastic_private_balloons = {}
                                if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000020 function! SyntasticBalloonsExprNotifier() abort " {{{2
                                if !exists('b:syntastic_private_balloons')
                                    return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/checker.vim
Sourced 2 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_checker = 1
                            
    1              0.000003 let g:SyntasticChecker = {}
                            
                            " Public methods {{{1
                            
    1              0.000003 function! g:SyntasticChecker.New(args, ...) abort " {{{2
                                let newObj = copy(self)
                            
                                let newObj._filetype = a:args['filetype']
                                let newObj._name = a:args['name']
                            
                                if a:0
                                    " redirected checker
                                    let newObj._exec = get(a:args, 'exec', a:1['_exec'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
                                    let newObj._exec = get(a:args, 'exec', newObj._name)
                                    let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
                                endif
                            
                                let newObj._locListFunc = function(prefix . 'GetLocList')
                            
                                if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
                                else
                                    let newObj._isAvailableFunc = function('s:_isAvailableDefault')
                                endif
                            
                                if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getFiletype() abort " {{{2
                                return self._filetype
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getName() abort " {{{2
                                return self._name
                            endfunction " }}}2
                            
                            " Synchronise _exec with user's setting.  Force re-validation if needed.
                            "
                            " XXX: This function must be called at least once before calling either
                            " getExec() or getExecEscaped().  Normally isAvailable() does that for you
                            " automatically, but you should keep still this in mind if you change the
                            " current checker workflow.
    1              0.000002 function! g:SyntasticChecker.syncExec() abort " {{{2
                                let user_exec =
                                    \ expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec :
                                    \ syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
                                if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getExec() abort " {{{2
                                return self._exec
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker.getExecEscaped() abort " {{{2
                                return syntastic#util#shescape(self._exec)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getLocListRaw() abort " {{{2
                                let name = self._filetype . '/' . self._name
                            
                                if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) .
                                            \ ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' .
                                            \ 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
                                try
                                    let list = self._locListFunc()
                                    if self._exec !=# ''
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
                                    endif
                                catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
                                call self._populateHighlightRegexes(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
                                call self._quietMessages(list)
                                return list
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker.getLocList() abort " {{{2
                                return g:SyntasticLoclist.New(self.getLocListRaw())
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getVersion(...) abort " {{{2
                                if !exists('self._version')
                                    let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
                                    let version_output = syntastic#util#system(command)
                                    call self.log('getVersion: ' . string(command) . ': ' .
                                        \ string(split(version_output, "\n", 1)) .
                                        \ (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
                                    let parsed_ver = syntastic#util#parseVersion(version_output)
                                    if len(parsed_ver)
                                        call self.setVersion(parsed_ver)
                                    else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self._filetype . "/" . self._name . ": can't parse version string (abnormal termination?)")
                                    endif
                                endif
                                return get(self, '_version', [])
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.setVersion(version) abort " {{{2
                                if len(a:version)
                                    let self._version = copy(a:version)
                                    call self.log(self.getExec() . ' version =', a:version)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.log(msg, ...) abort " {{{2
                                let leader = self._filetype . '/' . self._name . ': '
                                if a:0 > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker.makeprgBuild(opts) abort " {{{2
                                let basename = self._filetype . '_' . self._name . '_'
                            
                                let parts = []
                                call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
                                call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
                                call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
                                return join(parts)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.isAvailable() abort " {{{2
                                call self.syncExec()
                                if !has_key(self, '_available')
                                    let self._available = self._isAvailableFunc()
                                endif
                                return self._available
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.isDisabled() abort " {{{2
                                return has_key(self, '_enable') && syntastic#util#var(self._enable, -1) <= 0
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker.wantSort() abort " {{{2
                                return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)
                            endfunction " }}}2
                            
                            " This method is no longer used by syntastic.  It's here only to maintain
                            " backwards compatibility with external checkers which might depend on it.
    1              0.000003 function! g:SyntasticChecker.setWantSort(val) abort " {{{2
                                if !exists('g:syntastic_' . self._filetype . '_' . self._name . '_sort')
                                    let g:syntastic_{self._filetype}_{self._name}_sort = a:val
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticChecker._quietMessages(errors) abort " {{{2
                                " wildcard quiet_messages
                                let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
                                if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
                                let name = self._filetype . '_' . self._name
                                try
                                    call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
                                catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
                                if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker._populateHighlightRegexes(errors) abort " {{{2
                                if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticChecker._getOpt(opts, basename, name, default) abort " {{{2
                                let ret = []
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
                                call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
                                return ret
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000004 function! s:_isAvailableDefault() dict " {{{2
                                return executable(self.getExec())
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/cursor.vim
Sourced 2 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_cursor = 1
                            
    1              0.000003 let g:SyntasticCursorNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticCursorNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticCursorNotifier.enabled() abort " {{{2
                                return syntastic#util#var('echo_current_error')
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticCursorNotifier.refresh(loclist) abort " {{{2
                                if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif
                            endfunction " }}}2
                            
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000003 function! g:SyntasticCursorNotifier.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
                                autocmd! syntastic CursorMoved
                                unlet! b:syntastic_private_messages
                                let b:syntastic_private_line = -1
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000003 function! SyntasticRefreshCursor() abort " {{{2
                                if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000005 function! s:_is_same_index(line, old_line, column, idx, messages) abort " {{{2
                                if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000004 function! s:_find_index(column, messages) abort " {{{2
                                let max = len(a:messages) - 1
                                if max == 0
                                    return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/highlighting.vim
Sourced 2 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_highlighting = 1
                            
                            " Highlighting requires getmatches introduced in 7.1.040
    1              0.000007 let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
    1              0.000004 lockvar s:has_highlighting
                            
    1              0.000003 let g:SyntasticHighlightingNotifier = {}
                            
    1              0.000002 let s:setup_done = 0
                            
                            " Public methods {{{1
                            
    1              0.000003 function! g:SyntasticHighlightingNotifier.New() abort " {{{2
                                let newObj = copy(self)
                            
                                if !s:setup_done
                                    call self._setup()
                                    let s:setup_done = 1
                                    lockvar s:setup_done
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticHighlightingNotifier.enabled() abort " {{{2
                                return s:has_highlighting && syntastic#util#var('enable_highlighting')
                            endfunction " }}}2
                            
                            " Sets error highlights in the current window
    1              0.000002 function! g:SyntasticHighlightingNotifier.refresh(loclist) abort " {{{2
                                if self.enabled()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
                                    call self._reset()
                                    let buf = bufnr('')
                                    let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
                                    for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove all error highlights from the window
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000003 function! g:SyntasticHighlightingNotifier.reset(loclist) abort " {{{2
                                if s:has_highlighting
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
                                    call self._reset()
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own highlighting
    1              0.000002 function! g:SyntasticHighlightingNotifier._setup() abort " {{{2
                                if s:has_highlighting
                                    if !hlexists('SyntasticError')
                                        highlight link SyntasticError SpellBad
                                    endif
                                    if !hlexists('SyntasticWarning')
                                        highlight link SyntasticWarning SpellCap
                                    endif
                                    if !hlexists('SyntasticStyleError')
                                        highlight link SyntasticStyleError SyntasticError
                                    endif
                                    if !hlexists('SyntasticStyleWarning')
                                        highlight link SyntasticStyleWarning SyntasticWarning
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticHighlightingNotifier._reset() abort " {{{2
                                for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/loclist.vim
Sourced 2 times
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_loclist = 1
                            
    1              0.000003 let g:SyntasticLoclist = {}
                            
                            " Public methods {{{1
                            
    1              0.000003 function! g:SyntasticLoclist.New(rawLoclist) abort " {{{2
                                let newObj = copy(self)
                            
                                let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
                                for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
                                let newObj._rawLoclist = llist
                                let newObj._name = ''
                                let newObj._owner = bufnr('')
                                let newObj._sorted = 0
                                let newObj._columns = g:syntastic_cursor_columns
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.current() abort " {{{2
                                if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
                                return b:syntastic_loclist
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticLoclist.extend(other) abort " {{{2
                                let list = self.copyRaw()
                                call extend(list, a:other.copyRaw())
                                return g:SyntasticLoclist.New(list)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.sort() abort " {{{2
                                if !self._sorted
                                    for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
                                    call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
                                    let self._sorted = 1
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.isEmpty() abort " {{{2
                                return empty(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.isNewerThan(stamp) abort " {{{2
                                if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
                                return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.copyRaw() abort " {{{2
                                return copy(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getRaw() abort " {{{2
                                return self._rawLoclist
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getBuffers() abort " {{{2
                                return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getCursorColumns() abort " {{{2
                                return self._columns
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getStatuslineFlag() abort " {{{2
                                if !exists('self._stl_format')
                                    let self._stl_format = ''
                                endif
                                if !exists('self._stl_flag')
                                    let self._stl_flag = ''
                                endif
                            
                                if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = {
                                            \ '%':  '%',
                                            \ 't':  num_issues,
                                            \ 'e':  num_errors,
                                            \ 'w':  num_warnings,
                                            \ 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''),
                                            \ 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''),
                                            \ 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''),
                                            \ 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fe': (num_errors ? errors[0]['lnum'] : ''),
                                            \ 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''),
                                            \ 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
                                return self._stl_flag
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticLoclist.getFirstError(...) abort " {{{2
                                let max_issues = len(self._rawLoclist)
                                if a:0 && a:1 < max_issues
                                    let max_issues = a:1
                                endif
                            
                                for idx in range(max_issues)
                                    if get(self._rawLoclist[idx], 'type', '') ==? 'E'
                                        return idx + 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getName() abort " {{{2
                                return len(self._name)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.setName(name) abort " {{{2
                                let self._name = a:name
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.getOwner() abort " {{{2
                                return self._owner
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticLoclist.setOwner(buffer) abort " {{{2
                                let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.deploy() abort " {{{2
                                call self.setOwner(bufnr(''))
                                let self._stamp = syntastic#util#stamp()
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', self)
                                endfor
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.destroy() abort " {{{2
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', {})
                                endfor
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.decorate(tag) abort " {{{2
                                for e in self._rawLoclist
                                    let e['text'] .= ' [' . a:tag . ']'
                                endfor
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.balloons() abort " {{{2
                                if !exists('self._cachedBalloons')
                                    let sep = has('balloon_multiline') ? "\n" : ' | '
                            
                                    let self._cachedBalloons = {}
                                    for e in self._rawLoclist
                                        let buf = e['bufnr']
                            
                                        if !has_key(self._cachedBalloons, buf)
                                            let self._cachedBalloons[buf] = {}
                                        endif
                            
                                        if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
                                            let self._cachedBalloons[buf][e['lnum']] = e['text']
                                        endif
                                    endfor
                                endif
                            
                                return get(self._cachedBalloons, bufnr(''), {})
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.errors() abort " {{{2
                                if !exists('self._cachedErrors')
                                    let self._cachedErrors = self.filter({'type': 'E'})
                                endif
                                return self._cachedErrors
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.warnings() abort " {{{2
                                if !exists('self._cachedWarnings')
                                    let self._cachedWarnings = self.filter({'type': 'W'})
                                endif
                                return self._cachedWarnings
                            endfunction " }}}2
                            
                            " Legacy function.  Syntastic no longer calls it, but we keep it
                            " around because other plugins (f.i. powerline) depend on it.
    1              0.000002 function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() abort " {{{2
                                return !self.isEmpty()
                            endfunction " }}}2
                            
                            " cache used by EchoCurrentError()
    1              0.000003 function! g:SyntasticLoclist.messages(buf) abort " {{{2
                                if !exists('self._cachedMessages')
                                    let self._cachedMessages = {}
                            
                                    let errors = self.errors() + self.warnings()
                                    for e in errors
                                        let b = e['bufnr']
                                        let l = e['lnum']
                            
                                        if !has_key(self._cachedMessages, b)
                                            let self._cachedMessages[b] = {}
                                        endif
                            
                                        if !has_key(self._cachedMessages[b], l)
                                            let self._cachedMessages[b][l] = [e]
                                        elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
                                    endfor
                            
                                    if self._columns
                                        if !self._sorted
                                            for b in keys(self._cachedMessages)
                                                for l in keys(self._cachedMessages[b])
                                                    if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
                                                endfor
                                            endfor
                                        endif
                            
                                        for b in keys(self._cachedMessages)
                                            for l in keys(self._cachedMessages[b])
                                                call s:_remove_shadowed_items(self._cachedMessages[b][l])
                                            endfor
                                        endfor
                                    endif
                                endif
                            
                                return get(self._cachedMessages, a:buf, {})
                            endfunction " }}}2
                            
                            "Filter the list and return new native loclist
                            "e.g.
                            "  .filter({'bufnr': 10, 'type': 'e'})
                            "
                            "would return all errors for buffer 10.
                            "
                            "Note that all comparisons are done with ==?
    1              0.000002 function! g:SyntasticLoclist.filter(filters) abort " {{{2
                                let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
                                let filter = len(conditions) == 1 ?
                                    \ conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                                return filter(copy(self._rawLoclist), filter)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.setloclist() abort " {{{2
                                if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = 0
                                endif
                                let replace = g:syntastic_reuse_loc_lists && w:syntastic_loclist_set
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
                                call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
                                let w:syntastic_loclist_set = 1
                            endfunction " }}}2
                            
                            "display the cached errors for this buf in the location list
    1              0.000003 function! g:SyntasticLoclist.show() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
                                call self.setloclist()
                            
                                if !self.isEmpty()
                                    let num = winnr()
                                    execute 'lopen ' . syntastic#util#var('loc_list_height')
                                    if num != winnr()
                                        execute num . 'wincmd w'
                                    endif
                            
                                    " try to find the loclist window and set w:quickfix_title
                                    let errors = getloclist(0)
                                    for buf in tabpagebuflist()
                                        if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
                                            let win = bufwinnr(buf)
                                            let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
                                            if strpart(title, 0, 16) ==# ':SyntasticCheck ' ||
                                                        \ ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
                                                call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
                                                call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Public functions {{{1
                            
    1              0.000003 function! SyntasticLoclistHide() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
                                silent! lclose
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_translate(key, val) abort " {{{2
                                return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)
                            endfunction " }}}2
                            
    1              0.000003 function! s:_set_screen_column(item) abort " {{{2
                                if !has_key(a:item, 'scol')
                                    let col = get(a:item, 'col', 0)
                                    if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
                                        let a:item['scol'] = col
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_remove_shadowed_items(errors) abort " {{{2
                                " keep only the first message at a given column
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            endfunction " }}}2
                            
    1              0.000004 function! s:_compare_error_items_by_columns(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000004 function! s:_compare_error_items_by_lines(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/modemap.vim
Sourced 2 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_modemap = 1
                            
    1              0.000003 let g:SyntasticModeMap = {}
                            
                            " Public methods {{{1
                            
    1              0.000003 function! g:SyntasticModeMap.Instance() abort " {{{2
                                if !exists('s:SyntasticModeMapInstance')
                                    let s:SyntasticModeMapInstance = copy(self)
                                    call s:SyntasticModeMapInstance.synch()
                                endif
                            
                                return s:SyntasticModeMapInstance
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.synch() abort " {{{2
                                if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
                                    let self._mode = 'active'
                                    let self._activeFiletypes = []
                                    let self._passiveFiletypes = []
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.allowsAutoChecking(filetype) abort " {{{2
                                let fts = split(a:filetype, '\m\.')
                            
                                if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
                                    return self._noFiletypesArePassive(fts)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.doAutoChecking() abort " {{{2
                                let local_mode = get(b:, 'syntastic_mode', '')
                                if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
                                return self.allowsAutoChecking(&filetype)
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.isPassive() abort " {{{2
                                return self._mode ==# 'passive'
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.toggleMode() abort " {{{2
                                call self.synch()
                            
                                if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
                                    let self._mode = 'active'
                                endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
                                if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
                                let g:syntastic_mode_map['mode'] = self._mode
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.echoMode() abort " {{{2
                                echo 'Syntastic: ' . self._mode . ' mode enabled'
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.modeInfo(filetypes) abort " {{{2
                                echomsg 'Syntastic version: ' . g:_SYNTASTIC_VERSION . ' (Vim ' . v:version . ', ' . g:_SYNTASTIC_UNAME . ')'
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                echomsg 'Info for filetype: ' . type
                            
                                call self.synch()
                                echomsg 'Global mode: ' . self._mode
                                if self._mode ==# 'active'
                                    if len(self._passiveFiletypes)
                                        let plural = len(self._passiveFiletypes) != 1 ? 's' : ''
                                        echomsg 'Passive filetype' . plural . ': ' . join(sort(copy(self._passiveFiletypes)))
                                    endif
                                else
                                    if len(self._activeFiletypes)
                                        let plural = len(self._activeFiletypes) != 1 ? 's' : ''
                                        echomsg 'Active filetype' . plural . ': ' . join(sort(copy(self._activeFiletypes)))
                                    endif
                                endif
                                echomsg 'Filetype ' . type . ' is ' . (self.allowsAutoChecking(type) ? 'active' : 'passive')
                            
                                if !len(a:filetypes)
                                    if exists('b:syntastic_mode') && (b:syntastic_mode ==# 'active' || b:syntastic_mode ==# 'passive')
                                        echomsg 'Local mode: ' . b:syntastic_mode
                                    endif
                            
                                    echomsg 'The current file will ' . (self.doAutoChecking() ? '' : 'not ') . 'be checked automatically'
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000003 function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) abort " {{{2
                                return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) abort " {{{2
                                return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/notifiers.vim
Sourced 2 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_notifiers = 1
                            
    1              0.000003 let g:SyntasticNotifiers = {}
                            
    1              0.000005 let s:_NOTIFIER_TYPES = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
    1              0.000003 lockvar! s:_NOTIFIER_TYPES
                            
    1              0.000004 let s:_PERSISTENT_NOTIFIERS = ['signs', 'balloons']
    1              0.000002 lockvar! s:_PERSISTENT_NOTIFIERS
                            
                            " Public methods {{{1
                            
    1              0.000003 function! g:SyntasticNotifiers.Instance() abort " {{{2
                                if !exists('s:SyntasticNotifiersInstance')
                                    let s:SyntasticNotifiersInstance = copy(self)
                                    call s:SyntasticNotifiersInstance._initNotifiers()
                                endif
                            
                                return s:SyntasticNotifiersInstance
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticNotifiers.refresh(loclist) abort " {{{2
                                if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
                                        if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
                                            if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
                                            if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
                                                call self._notifier[type].refresh(a:loclist)
                                                let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
                                            endif
                                        else
                                            call self._notifier[type].refresh(a:loclist)
                                        endif
                                    endif
                                endfor
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticNotifiers.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
                                    if has_key(g:{class}, 'reset')
                                        call self._notifier[type].reset(a:loclist)
                                    endif
                            
                                    " also reset stamps
                                    if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                        let b:syntastic_private_{type}_stamp = []
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticNotifiers._initNotifiers() abort " {{{2
                                let self._notifier = {}
                                for type in s:_NOTIFIER_TYPES
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    let self._notifier[type] = g:{class}.New()
                                endfor
                            
                                let self._enabled_types = copy(s:_NOTIFIER_TYPES)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/registry.vim
Sourced 2 times
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000003 let g:loaded_syntastic_registry = 1
                            
                            " Initialisation {{{1
                            
    1              0.000149 let s:_DEFAULT_CHECKERS = {
                                    \ 'actionscript':  ['mxmlc'],
                                    \ 'ada':           ['gcc'],
                                    \ 'ansible':       ['ansible_lint'],
                                    \ 'apiblueprint':  ['drafter'],
                                    \ 'applescript':   ['osacompile'],
                                    \ 'asciidoc':      ['asciidoc'],
                                    \ 'asm':           ['gcc'],
                                    \ 'bro':           ['bro'],
                                    \ 'bemhtml':       ['bemhtmllint'],
                                    \ 'c':             ['gcc'],
                                    \ 'cabal':         ['cabal'],
                                    \ 'chef':          ['foodcritic'],
                                    \ 'co':            ['coco'],
                                    \ 'cobol':         ['cobc'],
                                    \ 'coffee':        ['coffee', 'coffeelint'],
                                    \ 'coq':           ['coqtop'],
                                    \ 'cpp':           ['gcc'],
                                    \ 'cs':            ['mcs'],
                                    \ 'css':           ['csslint'],
                                    \ 'cucumber':      ['cucumber'],
                                    \ 'cuda':          ['nvcc'],
                                    \ 'd':             ['dmd'],
                                    \ 'dart':          ['dartanalyzer'],
                                    \ 'docbk':         ['xmllint'],
                                    \ 'dockerfile':    ['dockerfile_lint'],
                                    \ 'dustjs':        ['swiffer'],
                                    \ 'elixir':        [],
                                    \ 'erlang':        ['escript'],
                                    \ 'eruby':         ['ruby'],
                                    \ 'fortran':       ['gfortran'],
                                    \ 'glsl':          ['cgc'],
                                    \ 'go':            ['go'],
                                    \ 'haml':          ['haml'],
                                    \ 'handlebars':    ['handlebars'],
                                    \ 'haskell':       ['ghc_mod', 'hdevtools', 'hlint'],
                                    \ 'haxe':          ['haxe'],
                                    \ 'hss':           ['hss'],
                                    \ 'html':          ['tidy'],
                                    \ 'jade':          ['jade_lint'],
                                    \ 'java':          ['javac'],
                                    \ 'javascript':    ['jshint', 'jslint'],
                                    \ 'json':          ['jsonlint', 'jsonval'],
                                    \ 'less':          ['lessc'],
                                    \ 'lex':           ['flex'],
                                    \ 'limbo':         ['limbo'],
                                    \ 'lisp':          ['clisp'],
                                    \ 'llvm':          ['llvm'],
                                    \ 'lua':           ['luac'],
                                    \ 'markdown':      ['mdl'],
                                    \ 'matlab':        ['mlint'],
                                    \ 'mercury':       ['mmc'],
                                    \ 'nasm':          ['nasm'],
                                    \ 'nix':           ['nix'],
                                    \ 'nroff':         ['mandoc'],
                                    \ 'objc':          ['gcc'],
                                    \ 'objcpp':        ['gcc'],
                                    \ 'ocaml':         ['camlp4o'],
                                    \ 'perl':          ['perlcritic'],
                                    \ 'php':           ['php', 'phpcs', 'phpmd'],
                                    \ 'po':            ['msgfmt'],
                                    \ 'pod':           ['podchecker'],
                                    \ 'puppet':        ['puppet', 'puppetlint'],
                                    \ 'python':        ['python', 'flake8', 'pylint'],
                                    \ 'qml':           ['qmllint'],
                                    \ 'r':             [],
                                    \ 'rmd':           [],
                                    \ 'racket':        ['racket'],
                                    \ 'rnc':           ['rnv'],
                                    \ 'rst':           ['rst2pseudoxml'],
                                    \ 'ruby':          ['mri'],
                                    \ 'sass':          ['sass'],
                                    \ 'scala':         ['fsc', 'scalac'],
                                    \ 'scss':          ['sass', 'scss_lint'],
                                    \ 'sh':            ['sh', 'shellcheck'],
                                    \ 'slim':          ['slimrb'],
                                    \ 'sml':           ['smlnj'],
                                    \ 'spec':          ['rpmlint'],
                                    \ 'sql':           ['sqlint'],
                                    \ 'stylus':        ['stylint'],
                                    \ 'tcl':           ['nagelfar'],
                                    \ 'tex':           ['lacheck', 'chktex'],
                                    \ 'texinfo':       ['makeinfo'],
                                    \ 'text':          [],
                                    \ 'twig':          ['twiglint'],
                                    \ 'typescript':    ['tsc'],
                                    \ 'vala':          ['valac'],
                                    \ 'verilog':       ['verilator'],
                                    \ 'vhdl':          ['ghdl'],
                                    \ 'vim':           ['vimlint'],
                                    \ 'xhtml':         ['tidy'],
                                    \ 'xml':           ['xmllint'],
                                    \ 'xslt':          ['xmllint'],
                                    \ 'xquery':        ['basex'],
                                    \ 'yacc':          ['bison'],
                                    \ 'yaml':          ['jsyaml'],
                                    \ 'z80':           ['z80syntaxchecker'],
                                    \ 'zpt':           ['zptlint'],
                                    \ 'zsh':           ['zsh'],
                                \ }
    1              0.000008 lockvar! s:_DEFAULT_CHECKERS
                            
    1              0.000014 let s:_DEFAULT_FILETYPE_MAP = {
                                    \ 'gentoo-metadata': 'xml',
                                    \ 'groff': 'nroff',
                                    \ 'lhaskell': 'haskell',
                                    \ 'litcoffee': 'coffee',
                                    \ 'mail': 'text',
                                    \ 'mkd': 'markdown',
                                    \ 'pe-puppet': 'puppet',
                                    \ 'sgml': 'docbk',
                                    \ 'sgmllnx': 'docbk',
                                \ }
    1              0.000003 lockvar! s:_DEFAULT_FILETYPE_MAP
                            
    1              0.000007 let s:_ECLIM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'html',
                                    \ 'java',
                                    \ 'php',
                                    \ 'python',
                                    \ 'ruby',
                                \ ]
    1              0.000003 lockvar! s:_ECLIM_TYPES
                            
    1              0.000006 let s:_YCM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'objc',
                                    \ 'objcpp',
                                \ ]
    1              0.000002 lockvar! s:_YCM_TYPES
                            
    1              0.000002 let g:SyntasticRegistry = {}
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
                            " Note: Handling of filetype aliases: all public methods take aliases as
                            " parameters, all private methods take normalized filetypes.  Public methods
                            " are thus supposed to normalize filetypes before calling private methods.
                            
    1              0.000003 function! g:SyntasticRegistry.Instance() abort " {{{2
                                if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
                                return s:SyntasticRegistryInstance
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticRegistry.CreateAndRegisterChecker(args) abort " {{{2
                                let registry = g:SyntasticRegistry.Instance()
                            
                                if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
                                    let checker = g:SyntasticChecker.New(a:args)
                                endif
                                call registry._registerChecker(checker)
                            endfunction " }}}2
                            
                            " Given a list of checker names hints_list, return a map name --> checker.
                            " If hints_list is empty, user settings are are used instead. Checkers are
                            " not checked for availability (that is, the corresponding IsAvailable() are
                            " not run).
    1              0.000003 function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) abort " {{{2
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft)
                            
                                let checkers_map = self._checkerMap[ft]
                                if empty(checkers_map)
                                    return []
                                endif
                            
                                call self._checkDeprecation(ft)
                            
                                let names =
                                    \ !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) :
                                    \ exists('b:syntastic_checkers') ? b:syntastic_checkers :
                                    \ exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers :
                                    \ get(s:_DEFAULT_CHECKERS, ft, 0)
                            
                                return type(names) == type([]) ?
                                    \ self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the available checkers.  This runs the
                            " corresponding IsAvailable() functions for all checkers.
    1              0.000002 function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isAvailable()')
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the checkers that are available and
                            " disabled.  This runs the corresponding IsAvailable() functions for all checkers.
    1              0.000003 function! g:SyntasticRegistry.getCheckersDisabled(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isDisabled() && v:val.isAvailable()')
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.getKnownFiletypes() abort " {{{2
                                let types = keys(s:_DEFAULT_CHECKERS)
                            
                                call extend(types, keys(s:_DEFAULT_FILETYPE_MAP))
                            
                                if exists('g:syntastic_filetype_map')
                                    call extend(types, keys(g:syntastic_filetype_map))
                                endif
                            
                                if exists('g:syntastic_extra_filetypes') && type(g:syntastic_extra_filetypes) == type([])
                                    call extend(types, g:syntastic_extra_filetypes)
                                endif
                            
                                return syntastic#util#unique(types)
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) abort " {{{2
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft)
                                return keys(filter( copy(self._checkerMap[ft]), 'v:val.isAvailable()' ))
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.echoInfoFor(ftalias_list) abort " {{{2
                                let ft_list = syntastic#util#unique(map( copy(a:ftalias_list), 's:_normalise_filetype(v:val)' ))
                                if len(ft_list) != 1
                                    let available = []
                                    let active = []
                                    let disabled = []
                            
                                    for ft in ft_list
                                        call extend(available, map( self.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                        call extend(active, map( self.getCheckersAvailable(ft, []), 'ft . "/" . v:val.getName()' ))
                                        call extend(disabled, map( self.getCheckersDisabled(ft, []), 'ft . "/" . v:val.getName()' ))
                                    endfor
                                else
                                    let ft = ft_list[0]
                                    let available = self.getNamesOfAvailableCheckers(ft)
                                    let active = map(self.getCheckersAvailable(ft, []), 'v:val.getName()')
                                    let disabled = map(self.getCheckersDisabled(ft, []), 'v:val.getName()')
                                endif
                            
                                let cnt = len(available)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(sort(available)) : '-'
                                echomsg 'Available checker' . plural . ': ' . cklist
                            
                                let cnt = len(active)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(active) : '-'
                                echomsg 'Currently enabled checker' . plural . ': ' . cklist
                            
                                let cnt = len(disabled)
                                let plural = cnt != 1 ? 's' : ''
                                if len(disabled)
                                    let cklist = join(sort(disabled))
                                    echomsg 'Checker' . plural . ' disabled for security reasons: ' . cklist
                                endif
                            
                                " Eclim feels entitled to mess with syntastic's variables {{{3
                                if exists(':EclimValidate') && get(g:, 'EclimFileTypeValidate', 1)
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_eclim(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by Eclim'
                                    endif
                                endif
                                " }}}3
                            
                                " So does YouCompleteMe {{{3
                                if exists('g:loaded_youcompleteme') && get(g:, 'ycm_show_diagnostics_ui', get(g:, 'ycm_register_as_syntastic_checker', 1))
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_ycm(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by YouCompleteMe'
                                    endif
                                endif
                                " }}}3
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
                                let ft = a:checker.getFiletype()
                                if !has_key(self._checkerMap, ft)
                                    let self._checkerMap[ft] = {}
                                endif
                            
                                let name = a:checker.getName()
                                if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
                                let self._checkerMap[ft][name] = a:checker
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticRegistry._filterCheckersByName(checkers_map, list) abort " {{{2
                                return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticRegistry._loadCheckersFor(filetype) abort " {{{2
                                if has_key(self._checkerMap, a:filetype)
                                    return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif
                            endfunction " }}}2
                            
                            " Check for obsolete variable g:syntastic_<filetype>_checker
    1              0.000003 function! g:SyntasticRegistry._checkDeprecation(filetype) abort " {{{2
                                if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
                            "resolve filetype aliases, and replace - with _ otherwise we cant name
                            "syntax checker functions legally for filetypes like "gentoo-metadata"
    1              0.000003 function! s:_normalise_filetype(ftalias) abort " {{{2
                                let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
                                let ft = get(g:syntastic_filetype_map, ft, ft)
                                let ft = substitute(ft, '\m-', '_', 'g')
                                return ft
                            endfunction " }}}2
                            
    1              0.000003 function! s:_disabled_by_eclim(filetype) abort " {{{2
                                if index(s:_ECLIM_TYPES, a:filetype) >= 0
                                    let lang = toupper(a:filetype[0]) . a:filetype[1:]
                                    let ft = a:filetype !=# 'cpp' ? lang : 'C'
                                    return get(g:, 'Eclim' . lang . 'Validate', 1) && !get(g:, 'Eclim' . ft . 'SyntasticEnabled', 0)
                                endif
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000003 function! s:_disabled_by_ycm(filetype) abort " {{{2
                                return index(s:_YCM_TYPES, a:filetype) >= 0
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic/signs.vim
Sourced 2 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')
    1              0.000002     finish
                            endif
    1              0.000004 let g:loaded_syntastic_notifier_signs = 1
                            
                            " Initialisation {{{1
                            
                            " start counting sign ids at 5000, start here to hopefully avoid conflicting
                            " with any other code that places signs (not sure if this precaution is
                            " actually needed)
    1              0.000003 let s:first_sign_id = 5000
    1              0.000003 let s:next_sign_id = s:first_sign_id
                            
    1              0.000003 let g:SyntasticSignsNotifier = {}
                            
    1              0.000002 let s:setup_done = 0
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticSignsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                            
                                if !s:setup_done
                                    call self._setup()
                                    let s:setup_done = 1
                                    lockvar s:setup_done
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticSignsNotifier.enabled() abort " {{{2
                                return has('signs') && syntastic#util#var('enable_signs')
                            endfunction " }}}2
                            
    1              0.000003 function! g:SyntasticSignsNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                                let old_signs = copy(self._bufSignIds())
                                if self.enabled()
                                    call self._signErrors(a:loclist)
                                endif
                                call self._removeSigns(old_signs)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own sign types and highlighting
    1              0.000002 function! g:SyntasticSignsNotifier._setup() abort " {{{2
                                if has('signs')
                                    if !hlexists('SyntasticErrorSign')
                                        highlight link SyntasticErrorSign error
                                    endif
                                    if !hlexists('SyntasticWarningSign')
                                        highlight link SyntasticWarningSign todo
                                    endif
                                    if !hlexists('SyntasticStyleErrorSign')
                                        highlight link SyntasticStyleErrorSign SyntasticErrorSign
                                    endif
                                    if !hlexists('SyntasticStyleWarningSign')
                                        highlight link SyntasticStyleWarningSign SyntasticWarningSign
                                    endif
                                    if !hlexists('SyntasticStyleErrorLine')
                                        highlight link SyntasticStyleErrorLine SyntasticErrorLine
                                    endif
                                    if !hlexists('SyntasticStyleWarningLine')
                                        highlight link SyntasticStyleWarningLine SyntasticWarningLine
                                    endif
                            
                                    " define the signs used to display syntax and style errors/warns
                                    execute 'sign define SyntasticError text=' . g:syntastic_error_symbol .
                                        \ ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
                                    execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol .
                                        \ ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
                                    execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol .
                                        \ ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
                                    execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol .
                                        \ ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
                                endif
                            endfunction " }}}2
                            
                            " Place signs by all syntax errors in the buffer
    1              0.000003 function! g:SyntasticSignsNotifier._signErrors(loclist) abort " {{{2
                                let loclist = a:loclist
                                if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove the signs with the given ids from this buffer
    1              0.000003 function! g:SyntasticSignsNotifier._removeSigns(ids) abort " {{{2
                                if has('signs')
                                    for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Get all the ids of the SyntaxError signs in the buffer
    1              0.000002 function! g:SyntasticSignsNotifier._bufSignIds() abort " {{{2
                                if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
                                return b:syntastic_private_sign_ids
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/plugin/syntastic.vim
Sourced 1 time
Total time:   0.017508
 Self time:   0.003583

count  total (s)   self (s)
                            "============================================================================
                            "File:        syntastic.vim
                            "Description: Vim plugin for on the fly syntax checking.
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000007 if exists('g:loaded_syntastic_plugin') || &compatible
                                finish
                            endif
    1              0.000005 let g:loaded_syntastic_plugin = 1
                            
    1              0.000005 if has('reltime')
    1              0.000005     let g:_SYNTASTIC_START = reltime()
    1              0.000004     lockvar! g:_SYNTASTIC_START
    1              0.000001 endif
                            
    1              0.000003 let g:_SYNTASTIC_VERSION = '3.7.0-62'
    1              0.000003 lockvar g:_SYNTASTIC_VERSION
                            
                            " Sanity checks {{{1
                            
    1              0.000004 if v:version < 700 || (v:version == 700 && !has('patch175'))
                                call syntastic#log#error('need Vim version 7.0.175 or later')
                                finish
                            endif
                            
    1              0.000010 for s:feature in [
                                        \ 'autocmd',
                                        \ 'eval',
                                        \ 'file_in_path',
                                        \ 'modify_fname',
                                        \ 'quickfix',
                                        \ 'reltime',
                                        \ 'user_commands'
    7              0.000012         \ ]
    7              0.000020     if !has(s:feature)
                                    call syntastic#log#error('need Vim compiled with feature ' . s:feature)
                                    finish
                                endif
    7              0.000006 endfor
                            
    1              0.000227 let s:_running_windows = syntastic#util#isRunningWindows()
    1              0.000003 lockvar s:_running_windows
                            
    1              0.000003 if !exists('g:syntastic_shell')
    1              0.000003     let g:syntastic_shell = &shell
    1              0.000001 endif
                            
    1              0.000002 if s:_running_windows
                                let g:_SYNTASTIC_UNAME = 'Windows'
                            elseif executable('uname')
    1              0.000003     try
    1   0.010668   0.000044         let g:_SYNTASTIC_UNAME = split(syntastic#util#system('uname'), "\n")[0]
    1              0.000009     catch /\m^Vim\%((\a\+)\)\=:E484/
                                    call syntastic#log#error("your shell " .  syntastic#util#var('shell') . " can't handle traditional UNIX syntax for redirections")
                                    finish
                                catch /\m^Vim\%((\a\+)\)\=:E684/
                                    let g:_SYNTASTIC_UNAME = 'Unknown'
                                endtry
    1              0.000001 else
                                let g:_SYNTASTIC_UNAME = 'Unknown'
                            endif
    1              0.000004 lockvar g:_SYNTASTIC_UNAME
                            
                            " }}}1
                            
                            " Defaults {{{1
                            
    1              0.000061 let g:_SYNTASTIC_DEFAULTS = {
                                    \ 'aggregate_errors':         0,
                                    \ 'always_populate_loc_list': 0,
                                    \ 'auto_jump':                0,
                                    \ 'auto_loc_list':            2,
                                    \ 'check_on_open':            0,
                                    \ 'check_on_wq':              1,
                                    \ 'cursor_columns':           1,
                                    \ 'debug':                    0,
                                    \ 'echo_current_error':       1,
                                    \ 'enable_balloons':          1,
                                    \ 'enable_highlighting':      1,
                                    \ 'enable_signs':             1,
                                    \ 'error_symbol':             '>>',
                                    \ 'exit_checks':              !(s:_running_windows && syntastic#util#var('shell', &shell) =~? '\m\<cmd\.exe$'),
                                    \ 'filetype_map':             {},
                                    \ 'full_redraws':             !(has('gui_running') || has('gui_macvim')),
                                    \ 'id_checkers':              1,
                                    \ 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$',
                                    \ 'ignore_files':             [],
                                    \ 'loc_list_height':          10,
                                    \ 'nested_autocommands':      0,
                                    \ 'quiet_messages':           {},
                                    \ 'reuse_loc_lists':          0,
                                    \ 'shell':                    &shell,
                                    \ 'sort_aggregated_errors':   1,
                                    \ 'stl_format':               '[Syntax: line:%F (%t)]',
                                    \ 'style_error_symbol':       'S>',
                                    \ 'style_warning_symbol':     'S>',
                                    \ 'warning_symbol':           '>>'
                                \ }
    1              0.000004 lockvar! g:_SYNTASTIC_DEFAULTS
                            
   30              0.000057 for s:key in keys(g:_SYNTASTIC_DEFAULTS)
   29              0.000098     if !exists('g:syntastic_' . s:key)
   27              0.000147         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
   27              0.000025     endif
   29              0.000020 endfor
                            
    1              0.000004 if exists('g:syntastic_quiet_warnings')
                                call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
                                if g:syntastic_quiet_warnings
                                    let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
                                    if type(s:quiet_warnings) != type([])
                                        let s:quiet_warnings = [s:quiet_warnings]
                                    endif
                                    call add(s:quiet_warnings, 'warnings')
                                    let g:syntastic_quiet_messages['type'] = s:quiet_warnings
                                endif
                            endif
                            
                            " }}}1
                            
                            " Debug {{{1
                            
    1              0.000010 let s:_DEBUG_DUMP_OPTIONS = [
                                    \ 'shell',
                                    \ 'shellcmdflag',
                                    \ 'shellpipe',
                                    \ 'shellquote',
                                    \ 'shellredir',
                                    \ 'shellslash',
                                    \ 'shelltemp',
                                    \ 'shellxquote'
                                \ ]
    1              0.000003 if exists('+shellxescape')
    1              0.000005     call add(s:_DEBUG_DUMP_OPTIONS, 'shellxescape')
    1              0.000002 endif
    1              0.000003 lockvar! s:_DEBUG_DUMP_OPTIONS
                            
                            " debug constants
    1              0.000004 let     g:_SYNTASTIC_DEBUG_TRACE         = 1
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_TRACE
    1              0.000003 let     g:_SYNTASTIC_DEBUG_LOCLIST       = 2
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_LOCLIST
    1              0.000003 let     g:_SYNTASTIC_DEBUG_NOTIFICATIONS = 4
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_NOTIFICATIONS
    1              0.000003 let     g:_SYNTASTIC_DEBUG_AUTOCOMMANDS  = 8
    1              0.000002 lockvar g:_SYNTASTIC_DEBUG_AUTOCOMMANDS
    1              0.000003 let     g:_SYNTASTIC_DEBUG_VARIABLES     = 16
    1              0.000003 lockvar g:_SYNTASTIC_DEBUG_VARIABLES
    1              0.000002 let     g:_SYNTASTIC_DEBUG_CHECKERS      = 32
    1              0.000003 lockvar g:_SYNTASTIC_DEBUG_CHECKERS
                            
                            " }}}1
                            
    1              0.000606 runtime! plugin/syntastic/*.vim
                            
    1   0.000037   0.000012 let s:registry = g:SyntasticRegistry.Instance()
    1   0.000405   0.000007 let s:notifiers = g:SyntasticNotifiers.Instance()
    1   0.000053   0.000007 let s:modemap = g:SyntasticModeMap.Instance()
                            
    1              0.000003 let s:_quit_pre = []
                            
                            " Commands {{{1
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000005 function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) abort " {{{2
                                let checker_names = []
                                for ft in s:_resolve_filetypes([])
                                    call extend(checker_names, s:registry.getNamesOfAvailableCheckers(ft))
                                endfor
                                return join(checker_names, "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000005 function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) abort " {{{2
                                return join(s:registry.getKnownFiletypes(), "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
    1              0.000021 command! -bar -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call SyntasticCheck(<f-args>)
    1              0.000013 command! -bar -nargs=? -complete=custom,s:CompleteFiletypes   SyntasticInfo  call SyntasticInfo(<f-args>)
    1              0.000008 command! -bar Errors              call SyntasticErrors()
    1              0.000007 command! -bar SyntasticReset      call SyntasticReset()
    1              0.000008 command! -bar SyntasticToggleMode call SyntasticToggleMode()
    1              0.000008 command! -bar SyntasticSetLoclist call SyntasticSetLoclist()
                            
    1              0.000014 command! SyntasticJavacEditClasspath runtime! syntax_checkers/java/*.vim | SyntasticJavacEditClasspath
    1              0.000013 command! SyntasticJavacEditConfig    runtime! syntax_checkers/java/*.vim | SyntasticJavacEditConfig
                            
                            " }}}1
                            
                            " Public API {{{1
                            
    1              0.000003 function! SyntasticCheck(...) abort " {{{2
                                call s:UpdateErrors(0, a:000)
                                call syntastic#util#redraw(g:syntastic_full_redraws)
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticInfo(...) abort " {{{2
                                call s:modemap.modeInfo(a:000)
                                call s:registry.echoInfoFor(s:_resolve_filetypes(a:000))
                                call s:_explain_skip(a:000)
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticErrors() abort " {{{2
                                call g:SyntasticLoclist.current().show()
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticReset() abort " {{{2
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticToggleMode() abort " {{{2
                                call s:modemap.toggleMode()
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                                call s:modemap.echoMode()
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticSetLoclist() abort " {{{2
                                call g:SyntasticLoclist.current().setloclist()
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Autocommands {{{1
                            
    1              0.000004 augroup syntastic
    1              0.000176     autocmd!
    1              0.000008     autocmd BufEnter * call s:BufEnterHook()
    1              0.000002 augroup END
                            
    1              0.000003 if g:syntastic_nested_autocommands
                                augroup syntastic
                                    autocmd BufReadPost  * nested call s:BufReadPostHook()
                                    autocmd BufWritePost * nested call s:BufWritePostHook()
                                augroup END
                            else
    1              0.000005     augroup syntastic
    1              0.000023         autocmd BufReadPost  * call s:BufReadPostHook()
    1              0.000008         autocmd BufWritePost * call s:BufWritePostHook()
    1              0.000002     augroup END
    1              0.000001 endif
                            
    1              0.000005 if exists('##QuitPre')
                                " QuitPre was added in Vim 7.3.544
    1              0.000002     augroup syntastic
    1              0.000006         autocmd QuitPre * call s:QuitPreHook(expand('<amatch>', 1))
    1              0.000002     augroup END
    1              0.000001 endif
                            
    1              0.000004 function! s:BufReadPostHook() abort " {{{2
                                if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                        \ 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                    call s:UpdateErrors(1, [])
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:BufWritePostHook() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                call s:UpdateErrors(1, [])
                            endfunction " }}}2
                            
    1              0.000003 function! s:BufEnterHook() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) .
                                    \ ', &buftype = ' . string(&buftype))
                                if &buftype ==# ''
                                    call s:notifiers.refresh(g:SyntasticLoclist.current())
                                elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if get(w:, 'syntastic_loclist_set', 0) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:QuitPreHook(fname) abort " {{{2
                                let buf = bufnr(fnameescape(a:fname))
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
                                if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
                                endif
                            
                                if get(w:, 'syntastic_loclist_set', 0)
                                    call SyntasticLoclistHide()
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Main {{{1
                            
                            "refresh and redraw all the error info for this buf when saving or reading
    1              0.000003 function! s:UpdateErrors(auto_invoked, checker_names) abort " {{{2
                                call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
                                call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
                                call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') .
                                    \ ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
                                call s:modemap.synch()
                            
                                if s:_skip_file()
                                    return
                                endif
                            
                                let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
                                if run_checks
                                    call s:CacheErrors(a:checker_names)
                                    unlockvar! b:syntastic_changedtick
                                    let b:syntastic_changedtick = b:changedtick
                                    lockvar! b:syntastic_changedtick
                                else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
                                let loclist = g:SyntasticLoclist.current()
                            
                                if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
                                let do_jump = syntastic#util#var('auto_jump') + 0
                                if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
                                let w:syntastic_loclist_set = 0
                                if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
                                call s:notifiers.refresh(loclist)
                            endfunction " }}}2
                            
                            "clear the loc list for the buffer
    1              0.000003 function! s:ClearCache() abort " {{{2
                                call s:notifiers.reset(g:SyntasticLoclist.current())
                                call b:syntastic_loclist.destroy()
                            endfunction " }}}2
                            
                            "detect and cache all syntax errors in this buffer
    1              0.000004 function! s:CacheErrors(checker_names) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' .
                                    \ (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                                call s:ClearCache()
                                let newLoclist = g:SyntasticLoclist.New([])
                            
                                if !s:_skip_file()
                                    " debug logging {{{3
                                    call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
                                    let filetypes = s:_resolve_filetypes([])
                                    let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
                                    let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
                                    let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
                                    let clist = []
                                    for type in filetypes
                                        call extend(clist, s:registry.getCheckers(type, a:checker_names))
                                    endfor
                            
                                    let names = []
                                    let unavailable_checkers = 0
                                    for checker in clist
                                        let cname = checker.getFiletype() . '/' . checker.getName()
                                        if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
                                    if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
                                    if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
                                    if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
                                endif
                            
                                call newLoclist.deploy()
                            endfunction " }}}2
                            
                            "Emulates the :lmake command. Sets up the make environment according to the
                            "options given, runs make, resets the environment, returns the location list
                            "
                            "a:options can contain the following keys:
                            "    'makeprg'
                            "    'errorformat'
                            "
                            "The corresponding options are set for the duration of the function call. They
                            "are set with :let, so dont escape spaces.
                            "
                            "a:options may also contain:
                            "   'defaults' - a dict containing default values for the returned errors
                            "   'subtype' - all errors will be assigned the given subtype
                            "   'preprocess' - a function to be applied to the error file before parsing errors
                            "   'postprocess' - a list of functions to be applied to the error list
                            "   'cwd' - change directory to the given path before running the checker
                            "   'env' - environment variables to set before running the checker
                            "   'returns' - a list of valid exit codes for the checker
                            " @vimlint(EVL102, 1, l:env_save)
    1              0.000004 function! SyntasticMake(options) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
                                let old_local_errorformat = &l:errorformat
                                let old_errorformat = &errorformat
                                let old_cwd = getcwd()
                                " }}}3
                            
                                if has_key(a:options, 'errorformat')
                                    let &errorformat = a:options['errorformat']
                                endif
                            
                                if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
                                let env_save = {}
                                if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
                                let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
                                if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
                                let bailout =
                                    \ syntastic#util#var('exit_checks') &&
                                    \ has_key(a:options, 'returns') &&
                                    \ index(a:options['returns'], v:shell_error) == -1
                            
                                if !bailout
                                    if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
                                    lgetexpr err_lines
                            
                                    let errors = deepcopy(getloclist(0))
                            
                                    if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
                                    try
                                        silent lolder
                                    catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
                                else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
                                let &errorformat = old_errorformat
                                let &l:errorformat = old_local_errorformat
                                " }}}3
                            
                                if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
                                if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
                                if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
                                if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
                                if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
                                return errors
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:env_save)
                            
                            "return a string representing the state of buffer according to
                            "g:syntastic_stl_format
                            "
                            "return '' if no errors are cached for the buffer
    1              0.000003 function! SyntasticStatuslineFlag() abort " {{{2
                                return g:SyntasticLoclist.current().getStatuslineFlag()
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000004 function! s:_resolve_filetypes(filetypes) abort " {{{2
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                return split( get(g:syntastic_filetype_map, type, type), '\m\.' )
                            endfunction " }}}2
                            
    1              0.000003 function! s:_ignore_file(filename) abort " {{{2
                                let fname = fnamemodify(a:filename, ':p')
                                for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
                                return 0
                            endfunction " }}}2
                            
    1              0.000003 function! s:_is_quitting(buf) abort " {{{2
                                let quitting = 0
                                if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
                                return quitting
                            endfunction " }}}2
                            
                            " Skip running in special buffers
    1              0.000003 function! s:_skip_file() abort " {{{2
                                let fname = expand('%', 1)
                                let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) ||
                                    \ (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') ||
                                    \ s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
                                return skip
                            endfunction " }}}2
                            
                            " Explain why checks will be skipped for the current file
    1              0.000003 function! s:_explain_skip(filetypes) abort " {{{2
                                if empty(a:filetypes) && s:_skip_file()
                                    let why = []
                                    let fname = expand('%', 1)
                            
                                    if s:_is_quitting(bufnr('%'))
                                        call add(why, 'quitting buffer')
                                    endif
                                    if get(b:, 'syntastic_skip_checks', 0)
                                        call add(why, 'b:syntastic_skip_checks set')
                                    endif
                                    if &buftype !=# ''
                                        call add(why, 'buftype = ' . string(&buftype))
                                    endif
                                    if !filereadable(fname)
                                        call add(why, 'file not readable / not local')
                                    endif
                                    if getwinvar(0, '&diff')
                                        call add(why, 'diff mode')
                                    endif
                                    if s:_ignore_file(fname)
                                        call add(why, 'filename matching g:syntastic_ignore_files')
                                    endif
                                    if fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                        call add(why, 'extension matching g:syntastic_ignore_extensions')
                                    endif
                            
                                    echomsg 'The current file will not be checked (' . join(why, ', ') . ')'
                                endif
                            endfunction " }}}2
                            
                            " Take a list of errors and add default values to them from a:options
    1              0.000004 function! s:_add_to_errors(errors, options) abort " {{{2
                                for err in a:errors
                                    for key in keys(a:options)
                                        if !has_key(err, key) || empty(err[key])
                                            let err[key] = a:options[key]
                                        endif
                                    endfor
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
    1              0.000003 function! s:_os_name() abort " {{{2
                                return g:_SYNTASTIC_UNAME
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/autoload/syntastic/util.vim
Sourced 1 time
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_util_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000004 let g:loaded_syntastic_util_autoload = 1
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
                            " Public functions {{{1
                            
    1              0.000005 function! syntastic#util#isRunningWindows() abort " {{{2
                                return has('win16') || has('win32') || has('win64')
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#DevNull() abort " {{{2
                                if syntastic#util#isRunningWindows()
                                    return 'NUL'
                                endif
                                return '/dev/null'
                            endfunction " }}}2
                            
                            " Get directory separator
    1              0.000003 function! syntastic#util#Slash() abort " {{{2
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#CygwinPath(path) abort " {{{2
                                return substitute(syntastic#util#system('cygpath -m ' . syntastic#util#shescape(a:path)), "\n", '', 'g')
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#system(command) abort " {{{2
                                let old_shell = &shell
                                let old_lc_messages = $LC_MESSAGES
                                let old_lc_all = $LC_ALL
                            
                                let &shell = syntastic#util#var('shell')
                                let $LC_MESSAGES = 'C'
                                let $LC_ALL = ''
                            
                                let out = system(a:command)
                            
                                let $LC_ALL = old_lc_all
                                let $LC_MESSAGES = old_lc_messages
                            
                                let &shell = old_shell
                            
                                return out
                            endfunction " }}}2
                            
                            " Create a temporary directory
    1              0.000003 function! syntastic#util#tmpdir() abort " {{{2
                                let tempdir = ''
                            
                                if (has('unix') || has('mac')) && executable('mktemp')
                                    " TODO: option "-t" to mktemp(1) is not portable
                                    let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
                                    let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . getpid() . '-XXXXXXXX'), "\n")
                                    if v:shell_error == 0 && len(out) == 1
                                        let tempdir = out[0]
                                    endif
                                endif
                            
                                if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . getpid()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . getpid())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . getpid()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . getpid()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
                                return tempdir
                            endfunction " }}}2
                            
                            " Recursively remove a directory
    1              0.000003 function! syntastic#util#rmrf(what) abort " {{{2
                                " try to make sure we don't delete directories we didn't create
                                if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
                                if  getftype(a:what) ==# 'dir'
                                    if !exists('s:rmrf')
                                        let s:rmrf =
                                            \ has('unix') || has('mac') ? 'rm -rf' :
                                            \ has('win32') || has('win64') ? 'rmdir /S /Q' :
                                            \ has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
                                    endif
                            
                                    if s:rmrf !=# ''
                                        silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
                                    else
                                        call s:_rmrf(a:what)
                                    endif
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
                            " Search the first 5 lines of the file for a magic number and return a map
                            " containing the args and the executable
                            "
                            " e.g.
                            "
                            " #!/usr/bin/perl -f -bar
                            "
                            " returns
                            "
                            " {'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
    1              0.000004 function! syntastic#util#parseShebang() abort " {{{2
                                for lnum in range(1, 5)
                                    let line = getline(lnum)
                                    if line =~# '^#!'
                                        let line = substitute(line, '\v^#!\s*(\S+/env(\s+-\S+)*\s+)?', '', '')
                                        let exe = matchstr(line, '\m^\S*\ze')
                                        let args = split(matchstr(line, '\m^\S*\zs.*'))
                                        return { 'exe': exe, 'args': args }
                                    endif
                                endfor
                            
                                return { 'exe': '', 'args': [] }
                            endfunction " }}}2
                            
                            " Get the value of a variable.  Allow local variables to override global ones.
    1              0.000003 function! syntastic#util#var(name, ...) abort " {{{2
                                return
                                    \ exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} :
                                    \ exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} :
                                    \ a:0 > 0 ? a:1 : ''
                            endfunction " }}}2
                            
                            " Parse a version string.  Return an array of version components.
    1              0.000004 function! syntastic#util#parseVersion(version, ...) abort " {{{2
                                return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')
                            endfunction " }}}2
                            
                            " Verify that the 'installed' version is at least the 'required' version.
                            "
                            " 'installed' and 'required' must be arrays. If they have different lengths,
                            " the "missing" elements will be assumed to be 0 for the purposes of checking.
                            "
                            " See http://semver.org for info about version numbers.
    1              0.000004 function! syntastic#util#versionIsAtLeast(installed, required) abort " {{{2
                                return syntastic#util#compareLexi(a:installed, a:required) >= 0
                            endfunction " }}}2
                            
                            " Almost lexicographic comparison of two lists of integers. :) If lists
                            " have different lengths, the "missing" elements are assumed to be 0.
    1              0.000004 function! syntastic#util#compareLexi(a, b) abort " {{{2
                                for idx in range(max([len(a:a), len(a:b)]))
                                    let a_element = str2nr(get(a:a, idx, 0))
                                    let b_element = str2nr(get(a:b, idx, 0))
                                    if a_element != b_element
                                        return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0
                            endfunction " }}}2
                            
                            " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
                            " and hope for the best :)
    1              0.000011 let s:_width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
    1              0.000003 lockvar s:_width
                            
    1              0.000004 function! syntastic#util#screenWidth(str, tabstop) abort " {{{2
                                let chunks = split(a:str, "\t", 1)
                                let width = s:_width(chunks[-1])
                                for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
                                return width
                            endfunction " }}}2
                            
                            " Print as much of a:msg as possible without "Press Enter" prompt appearing
    1              0.000003 function! syntastic#util#wideMsg(msg) abort " {{{2
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
                                let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
                                let msg = strpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                call syntastic#util#redraw(0)
                            
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd
                            endfunction " }}}2
                            
                            " Check whether a buffer is loaded, listed, and not hidden
    1              0.000004 function! syntastic#util#bufIsActive(buffer) abort " {{{2
                                " convert to number, or hell breaks loose
                                let buf = str2nr(a:buffer)
                            
                                if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
                                for tab in range(1, tabpagenr('$'))
                                    if index(tabpagebuflist(tab), buf) >= 0
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file named a:what; return path to that file
    1              0.000004 function! syntastic#util#findFileInParent(what, where) abort " {{{2
                                let old_suffixesadd = &suffixesadd
                                let &suffixesadd = ''
                                let file = findfile(a:what, escape(a:where, ' ') . ';')
                                let &suffixesadd = old_suffixesadd
                                return file
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file matching a:what; return path to that file
    1              0.000003 function! syntastic#util#findGlobInParent(what, where) abort " {{{2
                                let here = fnamemodify(a:where, ':p')
                            
                                let root = syntastic#util#Slash()
                                if syntastic#util#isRunningWindows() && here[1] ==# ':'
                                    " The drive letter is an ever-green source of fun.  That's because
                                    " we don't care about running syntastic on Amiga these days. ;)
                                    let root = fnamemodify(root, ':p')
                                    let root = here[0] . root[1:]
                                endif
                            
                                let old = ''
                                while here !=# ''
                                    let p = split(globpath(here, a:what, 1), '\n')
                            
                                    if !empty(p)
                                        return fnamemodify(p[0], ':p')
                                    elseif here ==? root || here ==? old
                                        break
                                    endif
                            
                                    let old = here
                            
                                    " we use ':h:h' rather than ':h' since ':p' adds a trailing '/'
                                    " if 'here' is a directory
                                    let here = fnamemodify(here, ':p:h:h')
                                endwhile
                            
                                return ''
                            endfunction " }}}2
                            
                            " Returns unique elements in a list
    1              0.000004 function! syntastic#util#unique(list) abort " {{{2
                                let seen = {}
                                let uniques = []
                                for e in a:list
                                    if !has_key(seen, e)
                                        let seen[e] = 1
                                        call add(uniques, e)
                                    endif
                                endfor
                                return uniques
                            endfunction " }}}2
                            
                            " A less noisy shellescape()
    1              0.000004 function! syntastic#util#shescape(string) abort " {{{2
                                return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
                            endfunction " }}}2
                            
                            " A less noisy shellescape(expand())
    1              0.000004 function! syntastic#util#shexpand(string, ...) abort " {{{2
                                return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))
                            endfunction " }}}2
                            
                            " Escape arguments
    1              0.000003 function! syntastic#util#argsescape(opt) abort " {{{2
                                if type(a:opt) == type('') && a:opt !=# ''
                                    return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
                                return []
                            endfunction " }}}2
                            
                            " Decode XML entities
    1              0.000003 function! syntastic#util#decodeXMLEntities(string) abort " {{{2
                                let str = a:string
                                let str = substitute(str, '\m&lt;', '<', 'g')
                                let str = substitute(str, '\m&gt;', '>', 'g')
                                let str = substitute(str, '\m&quot;', '"', 'g')
                                let str = substitute(str, '\m&apos;', "'", 'g')
                                let str = substitute(str, '\m&amp;', '\&', 'g')
                                return str
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#redraw(full) abort " {{{2
                                if a:full
                                    redraw!
                                else
                                    redraw
                                endif
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#util#dictFilter(errors, filter) abort " {{{2
                                let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
                                try
                                    call filter(a:errors, rules)
                                catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry
                            endfunction " }}}2
                            
                            " Return a [seconds, fractions] list of strings, representing the
                            " (hopefully high resolution) time since program start
    1              0.000003 function! syntastic#util#stamp() abort " {{{2
                                return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )
                            endfunction " }}}2
                            
    1              0.000012 let s:_wid_base = 'syntastic_' . getpid() . '_' . reltimestr(g:_SYNTASTIC_START) . '_'
    1              0.000003 let s:_wid_pool = 0
                            
                            " Add unique IDs to windows
    1              0.000003 function! syntastic#util#setWids() abort " {{{2
                                for tab in range(1, tabpagenr('$'))
                                    for win in range(1, tabpagewinnr(tab, '$'))
                                        if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
                                            call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
                                            let s:_wid_pool += 1
                                        endif
                                    endfor
                                endfor
                            endfunction " }}}2
                            
    1              0.000009 let s:_str2float = function(exists('*str2float') ? 'str2float' : 'str2nr')
    1              0.000003 lockvar s:_str2float
                            
    1              0.000003 function! syntastic#util#str2float(val) abort " {{{2
                                return s:_str2float(a:val)
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#util#float2str(val) abort " {{{2
                                return s:_float2str(a:val)
                            endfunction " }}}2
                            
                            " Crude printf()-like width formatter.  Handles wide characters.
    1              0.000004 function! syntastic#util#wformat(format, str) abort " {{{2
                                if a:format ==# ''
                                    return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000004 function! s:_translateFilter(filters) abort " {{{2
                                let conditions = []
                                for k in keys(a:filters)
                                    if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
                                        call add(conditions, s:_translateElement(k, a:filters[k]))
                                    endif
                                endfor
                            
                                if conditions == []
                                    let conditions = ['1']
                                endif
                                return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                            endfunction " }}}2
                            
    1              0.000003 function! s:_translateElement(key, term) abort " {{{2
                                let fkey = a:key
                                if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
                                    let not = 0
                                endif
                            
                                if fkey ==? 'level'
                                    let op = not ? ' ==? ' : ' !=? '
                                    let ret = 'v:val["type"]' . op . string(a:term[0])
                                elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
                                return ret
                            endfunction " }}}2
                            
    1              0.000003 function! s:_rmrf(what) abort " {{{2
                                if !exists('s:rmdir')
                                    let s:rmdir = syntastic#util#shescape(get(g:, 'netrw_localrmdir', 'rmdir'))
                                endif
                            
                                if getftype(a:what) ==# 'dir'
                                    if filewritable(a:what) != 2
                                        return
                                    endif
                            
                                    for f in split(globpath(a:what, '*', 1), "\n")
                                        call s:_rmrf(f)
                                    endfor
                                    silent! call syntastic#util#system(s:rmdir . ' ' . syntastic#util#shescape(a:what))
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
    1              0.000003 function! s:_float2str_smart(val) abort " {{{2
                                return printf('%.1f', a:val)
                            endfunction " }}}2
                            
    1              0.000003 function! s:_float2str_dumb(val) abort " {{{2
                                return a:val
                            endfunction " }}}2
                            
    1              0.000010 let s:_float2str = function(has('float') ? 's:_float2str_smart' : 's:_float2str_dumb')
    1              0.000002 lockvar s:_float2str
                            
                            " }}}1
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/autoload/syntastic/log.vim
Sourced 1 time
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
                            if exists('g:loaded_syntastic_log_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
                            endif
    1              0.000005 let g:loaded_syntastic_log_autoload = 1
                            
    1              0.000008 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000004 let s:one_time_notices_issued = []
                            
                            " Public functions {{{1
                            
    1              0.000004 function! syntastic#log#info(msg) abort " {{{2
                                echomsg 'syntastic: info: ' . a:msg
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#warn(msg) abort " {{{2
                                echohl WarningMsg
                                echomsg 'syntastic: warning: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000003 function! syntastic#log#error(msg) abort " {{{2
                                execute "normal \<Esc>"
                                echohl ErrorMsg
                                echomsg 'syntastic: error: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#oneTimeWarn(msg) abort " {{{2
                                if index(s:one_time_notices_issued, a:msg) >= 0
                                    return
                                endif
                            
                                call add(s:one_time_notices_issued, a:msg)
                                call syntastic#log#warn(a:msg)
                            endfunction " }}}2
                            
                            " @vimlint(EVL102, 1, l:OLD_VAR)
    1              0.000004 function! syntastic#log#deprecationWarn(old, new, ...) abort " {{{2
                                if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:OLD_VAR)
                            
    1              0.000004 function! syntastic#log#debug(level, msg, ...) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' .
                                        \ strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ?
                                        \ filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#debugShowOptions(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#debugShowVariables(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#debugDump(level) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )
                            endfunction " }}}2
                            
    1              0.000004 function! syntastic#log#ndebug(level, title, messages) abort " {{{2
                                if s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#error(a:title)
                                if type(a:messages) == type([])
                                    for msg in a:messages
                                        echomsg msg
                                    endfor
                                else
                                    echomsg a:messages
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000004 function! s:_isDebugEnabled_smart(level) abort " {{{2
                                return and(g:syntastic_debug, a:level)
                            endfunction " }}}2
                            
    1              0.000003 function! s:_isDebugEnabled_dumb(level) abort " {{{2
                                " poor man's bit test for bit N, assuming a:level == 2**N
                                return (g:syntastic_debug / a:level) % 2
                            endfunction " }}}2
                            
    1              0.000012 let s:_isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
    1              0.000004 lockvar s:_isDebugEnabled
                            
    1              0.000003 function! s:_logRedirect(on) abort " {{{2
                                if exists('g:syntastic_debug_file')
                                    if a:on
                                        try
                                            execute 'redir >> ' . fnameescape(expand(g:syntastic_debug_file, 1))
                                        catch /\m^Vim\%((\a\+)\)\=:/
                                            silent! redir END
                                            unlet g:syntastic_debug_file
                                        endtry
                                    else
                                        silent! redir END
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_log_timestamp() abort " {{{2
                                return 'syntastic: ' . split(reltimestr(reltime(g:_SYNTASTIC_START)))[0] . ': '
                            endfunction " }}}2
                            
    1              0.000002 function! s:_format_variable(name) abort " {{{2
                                let vals = []
                                if exists('g:syntastic_' . a:name)
                                    call add(vals, 'g:syntastic_' . a:name . ' = ' . strtrans(string(g:syntastic_{a:name})))
                                endif
                                if exists('b:syntastic_' . a:name)
                                    call add(vals, 'b:syntastic_' . a:name . ' = ' . strtrans(string(b:syntastic_{a:name})))
                                endif
                            
                                return join(vals, ', ')
                            endfunction " }}}2
                            
    1              0.000002 function! s:_is_modified(name) abort " {{{2
                                if !exists('s:option_defaults')
                                    let s:option_defaults = {}
                                endif
                                if !has_key(s:option_defaults, a:name)
                                    let opt_save = eval('&' . a:name)
                                    execute 'set ' . a:name . '&'
                                    let s:option_defaults[a:name] = eval('&' . a:name)
                                    execute 'let &' . a:name . ' = ' . string(opt_save)
                                endif
                            
                                return s:option_defaults[a:name] !=# eval('&' . a:name)
                            endfunction " }}}2
                            
                            " }}}1
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/syntax_checkers/dockerfile/dockerfile_lint.vim
Sourced 1 time
Total time:   0.000623
 Self time:   0.000244

count  total (s)   self (s)
                            "============================================================================
                            "File:        dockerfile_lint.vim
                            "Description: Syntax checking plugin for syntastic.vim using dockerfile-lint
                            "             (https://github.com/projectatomic/dockerfile-lint).
                            "Maintainer:  Tim Carry <tim at pixelastic dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000015 if exists('g:loaded_syntastic_dockerfile_dockerfile_lint_checker')
                                finish
                            endif
    1              0.000010 let g:loaded_syntastic_dockerfile_dockerfile_lint_checker = 1
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000020 set cpo&vim
                            
    1              0.000008 function! SyntaxCheckers_dockerfile_dockerfile_lint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_after': '-j',
                                    \ 'fname_before': '-f' })
                            
                                let errorformat = '%t:%n:%l:%m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'dockerfile_lint',
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                            
                                for e in loclist
                                    if e['nr']
                                        let e['subtype'] = 'Style'
                                    endif
                                    call remove(e, 'nr')
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000404   0.000025 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'dockerfile',
                                \ 'name': 'dockerfile_lint'})
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/matt/src/github/pfeff/dotfiles/vim/bundle/syntastic/syntax_checkers/markdown/mdl.vim
Sourced 1 time
Total time:   0.001483
 Self time:   0.000509

count  total (s)   self (s)
                            "============================================================================
                            "File:        mdl.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Charles Beynon <etothepiipower at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000029 if exists('g:loaded_syntastic_markdown_mdl_checker')
                                finish
                            endif
    1              0.000015 let g:loaded_syntastic_markdown_mdl_checker = 1
                            
    1              0.000015 if !exists('g:syntastic_markdown_mdl_sort')
    1              0.000015     let g:syntastic_markdown_mdl_sort = 1
    1              0.000007 endif
                            
    1              0.000037 let s:save_cpo = &cpo
    1              0.000036 set cpo&vim
                            
    1              0.000019 function! SyntaxCheckers_markdown_mdl_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '--warnings' })
                            
                                let errorformat =
                                    \ '%E%f:%l: %m,'.
                                    \ '%W%f: Kramdown Warning: %m found on line %l'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style' })
                            endfunction
                            
    1   0.001023   0.000049 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'markdown',
                                \ 'name': 'mdl'})
                            
    1              0.000040 let &cpo = s:save_cpo
    1              0.000013 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  3()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005     let newObj = copy(self)
    1              0.000002     return newObj

FUNCTION  4()
Called 19 times
Total time:   0.003644
 Self time:   0.000611

count  total (s)   self (s)
   19   0.000795   0.000297     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
   19   0.002799   0.000264     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  6()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005     let newObj = copy(self)
    1              0.000002     return newObj

FUNCTION  7()
Called 19 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
   19              0.000315     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  8()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                unlet! b:syntastic_private_balloons
                                if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  9()
Called 16 times
Total time:   0.000840
 Self time:   0.000840

count  total (s)   self (s)
   16              0.000163     let b:syntastic_private_balloons = {}
   16              0.000259     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  syntastic#log#debug()
Called 275 times
Total time:   0.007989
 Self time:   0.005132

count  total (s)   self (s)
  275   0.006563   0.003706     if !s:_isDebugEnabled(a:level)
  275              0.000828         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>62__disabled_by_eclim()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if index(s:_ECLIM_TYPES, a:filetype) >= 0
                                    let lang = toupper(a:filetype[0]) . a:filetype[1:]
                                    let ft = a:filetype !=# 'cpp' ? lang : 'C'
                                    return get(g:, 'Eclim' . lang . 'Validate', 1) && !get(g:, 'Eclim' . ft . 'SyntasticEnabled', 0)
                                endif
                            
                                return 0

FUNCTION  <SNR>64__add_to_errors()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for err in a:errors
                                    for key in keys(a:options)
                                        if !has_key(err, key) || empty(err[key])
                                            let err[key] = a:options[key]
                                        endif
                                    endfor
                                endfor
                            
                                return a:errors

FUNCTION  <SNR>64__skip_file()
Called 32 times
Total time:   0.009829
 Self time:   0.005517

count  total (s)   self (s)
   32              0.000428     let fname = expand('%', 1)
   32   0.008570   0.004258     let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
   32              0.000178     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
   32              0.000116     return skip

FUNCTION  <SNR>64_CacheErrors()
Called 16 times
Total time:   0.061774
 Self time:   0.011828

count  total (s)   self (s)
   16   0.000878   0.000408     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
   16   0.018094   0.000227     call s:ClearCache()
   16   0.002580   0.000448     let newLoclist = g:SyntasticLoclist.New([])
                            
   16   0.004847   0.000257     if !s:_skip_file()
                                    " debug logging {{{3
   16   0.000840   0.000308         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
   16   0.001215   0.000708         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
   16   0.000863   0.000446         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
   16   0.000989   0.000302         let filetypes = s:_resolve_filetypes([])
   16   0.000910   0.000375         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
   16              0.000184         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
   16              0.000170         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
   16              0.000087         let clist = []
   32              0.000187         for type in filetypes
   16   0.013620   0.000400             call extend(clist, s:registry.getCheckers(type, a:checker_names))
   16              0.000067         endfor
                            
   16              0.000107         let names = []
   16              0.000109         let unavailable_checkers = 0
   32              0.000166         for checker in clist
   16   0.000677   0.000439             let cname = checker.getFiletype() . '/' . checker.getName()
   16   0.002772   0.000185             if !checker.isAvailable()
   16   0.000835   0.000368                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
   16              0.000147                 let unavailable_checkers += 1
   16              0.000103                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
   16              0.000105         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
   16              0.000131         if len(clist) == unavailable_checkers
   16              0.000105             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
   16   0.000819   0.000347                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
   16              0.000045             endif
   16              0.000039         endif
                                    " }}}3
                            
   16   0.000718   0.000317         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
   16              0.000071         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
   16              0.000038     endif
                            
   16   0.005006   0.000182     call newLoclist.deploy()

FUNCTION  syntastic#util#str2float()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:_str2float(a:val)

FUNCTION  <SNR>65__float2str_smart()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return printf('%.1f', a:val)

FUNCTION  <SNR>64__is_quitting()
Called 32 times
Total time:   0.002114
 Self time:   0.002114

count  total (s)   self (s)
   32              0.000276     let quitting = 0
   32              0.000291     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
   32              0.000173     return quitting

FUNCTION  syntastic#log#debugShowOptions()
Called 16 times
Total time:   0.000419
 Self time:   0.000275

count  total (s)   self (s)
   16   0.000342   0.000198     if !s:_isDebugEnabled(a:level)
   16              0.000045         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  5()
Called 19 times
Total time:   0.002535
 Self time:   0.001360

count  total (s)   self (s)
   19   0.000716   0.000244     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
   19   0.000392   0.000225     if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
   19   0.000776   0.000240         if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
   19              0.000094             lclose
   19              0.000046         endif
   19              0.000048     endif

FUNCTION  SyntaxCheckers_markdown_mdl_GetLocList()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let makeprg = self.makeprgBuild({ 'args': '--warnings' })
                            
                                let errorformat = '%E%f:%l: %m,'. '%W%f: Kramdown Warning: %m found on line %l'
                            
                                return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'subtype': 'Style' })

FUNCTION  syntastic#util#tmpdir()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let tempdir = ''
                            
                                if (has('unix') || has('mac')) && executable('mktemp')
                                    " TODO: option "-t" to mktemp(1) is not portable
                                    let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
                                    let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . getpid() . '-XXXXXXXX'), "\n")
                                    if v:shell_error == 0 && len(out) == 1
                                        let tempdir = out[0]
                                    endif
                                endif
                            
                                if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . getpid()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . getpid())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . getpid()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . getpid()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
                                return tempdir

FUNCTION  syntastic#log#error()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                execute "normal \<Esc>"
                                echohl ErrorMsg
                                echomsg 'syntastic: error: ' . a:msg
                                echohl None

FUNCTION  SyntaxCheckers_dockerfile_dockerfile_lint_GetLocList()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let makeprg = self.makeprgBuild({ 'args_after': '-j', 'fname_before': '-f' })
                            
                                let errorformat = '%t:%n:%l:%m'
                            
                                let loclist = SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'preprocess': 'dockerfile_lint', 'defaults': {'bufnr': bufnr('')}, 'returns': [0, 1] })
                            
                                for e in loclist
                                    if e['nr']
                                        let e['subtype'] = 'Style'
                                    endif
                                    call remove(e, 'nr')
                                endfor
                            
                                return loclist

FUNCTION  <SNR>65__translateFilter()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let conditions = []
                                for k in keys(a:filters)
                                    if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
                                        call add(conditions, s:_translateElement(k, a:filters[k]))
                                    endif
                                endfor
                            
                                if conditions == []
                                    let conditions = ['1']
                                endif
                                return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')

FUNCTION  syntastic#util#shescape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>83__log_timestamp()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'syntastic: ' . split(reltimestr(reltime(g:_SYNTASTIC_START)))[0] . ': '

FUNCTION  <SNR>64__os_name()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return g:_SYNTASTIC_UNAME

FUNCTION  <SNR>64__resolve_filetypes()
Called 16 times
Total time:   0.000687
 Self time:   0.000687

count  total (s)   self (s)
   16              0.000243     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
   16              0.000400     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  syntastic#util#decodeXMLEntities()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let str = a:string
                                let str = substitute(str, '\m&lt;', '<', 'g')
                                let str = substitute(str, '\m&gt;', '>', 'g')
                                let str = substitute(str, '\m&quot;', '"', 'g')
                                let str = substitute(str, '\m&apos;', "'", 'g')
                                let str = substitute(str, '\m&amp;', '\&', 'g')
                                return str

FUNCTION  <SNR>65__float2str_dumb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:val

FUNCTION  syntastic#util#versionIsAtLeast()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#compareLexi(a:installed, a:required) >= 0

FUNCTION  syntastic#util#Slash()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  SyntasticSetLoclist()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call g:SyntasticLoclist.current().setloclist()

FUNCTION  SyntasticRefreshCursor()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  <SNR>59__compare_error_items_by_lines()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                endif

FUNCTION  <SNR>64_UpdateErrors()
Called 16 times
Total time:   0.119010
 Self time:   0.007148

count  total (s)   self (s)
   16   0.000755   0.000280     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
   16   0.000713   0.000294     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
   16   0.000640   0.000227     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
   16   0.000904   0.000508     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
   16   0.001429   0.000230     call s:modemap.synch()
                            
   16   0.005467   0.000228     if s:_skip_file()
                                    return
                                endif
                            
   16   0.003001   0.000360     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
   16              0.000079     if run_checks
   16   0.062144   0.000370         call s:CacheErrors(a:checker_names)
   16              0.000105         unlockvar! b:syntastic_changedtick
   16              0.000144         let b:syntastic_changedtick = b:changedtick
   16              0.000114         lockvar! b:syntastic_changedtick
   16              0.000045     else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
   16   0.000952   0.000338     let loclist = g:SyntasticLoclist.current()
                            
   16              0.000169     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
   16   0.000870   0.000349     let do_jump = syntastic#util#var('auto_jump') + 0
   16              0.000091     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
   16              0.000118     let w:syntastic_loclist_set = 0
   16   0.000836   0.000278     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
   16   0.037894   0.000281     call s:notifiers.refresh(loclist)

FUNCTION  10()
Called 2 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
    2              0.000076     let newObj = copy(self)
                            
    2              0.000027     let newObj._filetype = a:args['filetype']
    2              0.000022     let newObj._name = a:args['name']
                            
    2              0.000010     if a:0
                                    " redirected checker
                                    let newObj._exec = get(a:args, 'exec', a:1['_exec'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
    2              0.000035         let newObj._exec = get(a:args, 'exec', newObj._name)
    2              0.000038         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
    2              0.000020         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
    2              0.000006     endif
                            
    2              0.000044     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
    2              0.000033     if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
                                else
    2              0.000039         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    2              0.000007     endif
                            
    2              0.000028     if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
                                endif
                            
    2              0.000011     return newObj

FUNCTION  11()
Called 18 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   18              0.000110     return self._filetype

FUNCTION  12()
Called 18 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   18              0.000103     return self._name

FUNCTION  13()
Called 16 times
Total time:   0.001643
 Self time:   0.001231

count  total (s)   self (s)
   16   0.001093   0.000681     let user_exec = expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec'), 1 )
                            
   16              0.000132     if user_exec !=# '' && user_exec !=# self._exec
                                    let self._exec = user_exec
                                    if has_key(self, '_available')
                                        " we have a new _exec on the block, it has to be validated
                                        call remove(self, '_available')
                                    endif
                                endif

FUNCTION  14()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000009     return self._exec

FUNCTION  15()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#shescape(self._exec)

FUNCTION  16()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let name = self._filetype . '/' . self._name
                            
                                if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
                                try
                                    let list = self._locListFunc()
                                    if self._exec !=# ''
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
                                    endif
                                catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
                                call self._populateHighlightRegexes(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
                                call self._quietMessages(list)
                                return list

FUNCTION  17()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  18()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._version')
                                    let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
                                    let version_output = syntastic#util#system(command)
                                    call self.log('getVersion: ' . string(command) . ': ' . string(split(version_output, "\n", 1)) . (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
                                    let parsed_ver = syntastic#util#parseVersion(version_output)
                                    if len(parsed_ver)
                                        call self.setVersion(parsed_ver)
                                    else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self._filetype . "/" . self._name . ": can't parse version string (abnormal termination?)")
                                    endif
                                endif
                                return get(self, '_version', [])

FUNCTION  19()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if len(a:version)
                                    let self._version = copy(a:version)
                                    call self.log(self.getExec() . ' version =', a:version)
                                endif

FUNCTION  syntastic#util#stamp()
Called 35 times
Total time:   0.002167
 Self time:   0.002167

count  total (s)   self (s)
   35              0.002102     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  20()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let leader = self._filetype . '/' . self._name . ': '
                                if a:0 > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif

FUNCTION  21()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let basename = self._filetype . '_' . self._name . '_'
                            
                                let parts = []
                                call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
                                call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
                                call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
                                return join(parts)

FUNCTION  22()
Called 16 times
Total time:   0.002587
 Self time:   0.000590

count  total (s)   self (s)
   16   0.001823   0.000180     call self.syncExec()
   16              0.000121     if !has_key(self, '_available')
    2   0.000392   0.000038         let self._available = self._isAvailableFunc()
    2              0.000008     endif
   16              0.000065     return self._available

FUNCTION  23()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return has_key(self, '_enable') && syntastic#util#var(self._enable, -1) <= 0

FUNCTION  24()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  25()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('g:syntastic_' . self._filetype . '_' . self._name . '_sort')
                                    let g:syntastic_{self._filetype}_{self._name}_sort = a:val
                                endif

FUNCTION  26()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " wildcard quiet_messages
                                let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
                                if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
                                let name = self._filetype . '_' . self._name
                                try
                                    call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
                                catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
                                if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  27()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  28()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ret = []
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
                                call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
                                return ret

FUNCTION  29()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  syntastic#util#findFileInParent()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let old_suffixesadd = &suffixesadd
                                let &suffixesadd = ''
                                let file = findfile(a:what, escape(a:where, ' ') . ';')
                                let &suffixesadd = old_suffixesadd
                                return file

FUNCTION  syntastic#util#parseShebang()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for lnum in range(1, 5)
                                    let line = getline(lnum)
                                    if line =~# '^#!'
                                        let line = substitute(line, '\v^#!\s*(\S+/env(\s+-\S+)*\s+)?', '', '')
                                        let exe = matchstr(line, '\m^\S*\ze')
                                        let args = split(matchstr(line, '\m^\S*\zs.*'))
                                        return { 'exe': exe, 'args': args }
                                    endif
                                endfor
                            
                                return { 'exe': '', 'args': [] }

FUNCTION  <SNR>65__translateElement()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let fkey = a:key
                                if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
                                    let not = 0
                                endif
                            
                                if fkey ==? 'level'
                                    let op = not ? ' ==? ' : ' !=? '
                                    let ret = 'v:val["type"]' . op . string(a:term[0])
                                elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
                                return ret

FUNCTION  30()
Called 38 times
Total time:   0.001395
 Self time:   0.000450

count  total (s)   self (s)
   38   0.001344   0.000399     return syntastic#util#var('echo_current_error')

FUNCTION  31()
Called 19 times
Total time:   0.001818
 Self time:   0.001001

count  total (s)   self (s)
   19   0.001136   0.000319     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  32()
Called 16 times
Total time:   0.001203
 Self time:   0.000776

count  total (s)   self (s)
   16   0.000671   0.000244     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
   16              0.000256     autocmd! syntastic CursorMoved
   16              0.000098     unlet! b:syntastic_private_messages
   16              0.000121     let b:syntastic_private_line = -1

FUNCTION  33()
Called 1 time
Total time:   0.000061
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000006     let newObj = copy(self)
                            
    1              0.000002     if !s:setup_done
    1   0.000044   0.000004         call self._setup()
    1              0.000002         let s:setup_done = 1
    1              0.000003         lockvar s:setup_done
    1              0.000001     endif
                            
    1              0.000002     return newObj

FUNCTION  34()
Called 38 times
Total time:   0.001705
 Self time:   0.000603

count  total (s)   self (s)
   38   0.001653   0.000551     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  35()
Called 19 times
Total time:   0.005320
 Self time:   0.003186

count  total (s)   self (s)
   19   0.001010   0.000186     if self.enabled()
   19   0.000866   0.000337         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
   19   0.000809   0.000213         call self._reset()
   19              0.000174         let buf = bufnr('')
   19   0.000563   0.000378         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
   19              0.000123         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
   19              0.000044     endif

FUNCTION  36()
Called 16 times
Total time:   0.001703
 Self time:   0.000706

count  total (s)   self (s)
   16              0.000097     if s:has_highlighting
   16   0.000726   0.000265         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
   16   0.000776   0.000240         call self._reset()
   16              0.000045     endif

FUNCTION  37()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003     if s:has_highlighting
    1              0.000004         if !hlexists('SyntasticError')
    1              0.000004             highlight link SyntasticError SpellBad
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticWarning')
    1              0.000003             highlight link SyntasticWarning SpellCap
    1              0.000000         endif
    1              0.000002         if !hlexists('SyntasticStyleError')
    1              0.000006             highlight link SyntasticStyleError SyntasticError
    1              0.000001         endif
    1              0.000004         if !hlexists('SyntasticStyleWarning')
    1              0.000003             highlight link SyntasticStyleWarning SyntasticWarning
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  38()
Called 35 times
Total time:   0.001132
 Self time:   0.001132

count  total (s)   self (s)
   35              0.000350     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  39()
Called 19 times
Total time:   0.002319
 Self time:   0.002319

count  total (s)   self (s)
   19              0.000654     let newObj = copy(self)
                            
   19              0.000281     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
   19              0.000108     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
   19              0.000146     let newObj._rawLoclist = llist
   19              0.000106     let newObj._name = ''
   19              0.000165     let newObj._owner = bufnr('')
   19              0.000108     let newObj._sorted = 0
   19              0.000151     let newObj._columns = g:syntastic_cursor_columns
                            
   19              0.000074     return newObj

FUNCTION  syntastic#util#float2str()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:_float2str(a:val)

FUNCTION  <SNR>65__rmrf()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:rmdir')
                                    let s:rmdir = syntastic#util#shescape(get(g:, 'netrw_localrmdir', 'rmdir'))
                                endif
                            
                                if getftype(a:what) ==# 'dir'
                                    if filewritable(a:what) != 2
                                        return
                                    endif
                            
                                    for f in split(globpath(a:what, '*', 1), "\n")
                                        call s:_rmrf(f)
                                    endfor
                                    silent! call syntastic#util#system(s:rmdir . ' ' . syntastic#util#shescape(a:what))
                                else
                                    silent! call delete(a:what)
                                endif

FUNCTION  <SNR>59__translate()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  40()
Called 35 times
Total time:   0.001390
 Self time:   0.001203

count  total (s)   self (s)
   35              0.000567     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
    3   0.000215   0.000028         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    3              0.000003     endif
   35              0.000158     return b:syntastic_loclist

FUNCTION  41()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let list = self.copyRaw()
                                call extend(list, a:other.copyRaw())
                                return g:SyntasticLoclist.New(list)

FUNCTION  42()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !self._sorted
                                    for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
                                    call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
                                    let self._sorted = 1
                                endif

FUNCTION  44()
Called 19 times
Total time:   0.001834
 Self time:   0.000687

count  total (s)   self (s)
   19              0.000162     if !exists('self._stamp')
    3              0.000010         let self._stamp = []
    3              0.000005         return 0
                                endif
   16   0.001429   0.000282     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  46()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._rawLoclist

FUNCTION  47()
Called 32 times
Total time:   0.004058
 Self time:   0.001068

count  total (s)   self (s)
   32   0.003991   0.001001     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  48()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._columns

FUNCTION  49()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._stl_format')
                                    let self._stl_format = ''
                                endif
                                if !exists('self._stl_flag')
                                    let self._stl_flag = ''
                                endif
                            
                                if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
                                return self._stl_flag

FUNCTION  <SNR>64_BufEnterHook()
Called 3 times
Total time:   0.004004
 Self time:   0.000457

count  total (s)   self (s)
    3   0.000681   0.000326     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) . ', &buftype = ' . string(&buftype))
    3              0.000007     if &buftype ==# ''
    3   0.003232   0.000040         call s:notifiers.refresh(g:SyntasticLoclist.current())
    3              0.000005     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if get(w:, 'syntastic_loclist_set', 0) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  syntastic#util#redraw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:full
                                    redraw!
                                else
                                    redraw
                                endif

FUNCTION  syntastic#log#oneTimeWarn()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if index(s:one_time_notices_issued, a:msg) >= 0
                                    return
                                endif
                            
                                call add(s:one_time_notices_issued, a:msg)
                                call syntastic#log#warn(a:msg)

FUNCTION  50()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let max_issues = len(self._rawLoclist)
                                if a:0 && a:1 < max_issues
                                    let max_issues = a:1
                                endif
                            
                                for idx in range(max_issues)
                                    if get(self._rawLoclist[idx], 'type', '') ==? 'E'
                                        return idx + 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  51()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return len(self._name)

FUNCTION  52()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let self._name = a:name

FUNCTION  53()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._owner

FUNCTION  54()
Called 16 times
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
   16              0.000261     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  55()
Called 16 times
Total time:   0.004824
 Self time:   0.001407

count  total (s)   self (s)
   16   0.000530   0.000243     call self.setOwner(bufnr(''))
   16   0.001322   0.000267     let self._stamp = syntastic#util#stamp()
   32   0.002428   0.000353     for buf in self.getBuffers()
   16              0.000259         call setbufvar(buf, 'syntastic_loclist', self)
   16              0.000059     endfor

FUNCTION  56()
Called 16 times
Total time:   0.002868
 Self time:   0.000885

count  total (s)   self (s)
   32   0.002301   0.000318     for buf in self.getBuffers()
   16              0.000290         call setbufvar(buf, 'syntastic_loclist', {})
   16              0.000057     endfor

FUNCTION  57()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for e in self._rawLoclist
                                    let e['text'] .= ' [' . a:tag . ']'
                                endfor

FUNCTION  58()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedBalloons')
                                    let sep = has('balloon_multiline') ? "\n" : ' | '
                            
                                    let self._cachedBalloons = {}
                                    for e in self._rawLoclist
                                        let buf = e['bufnr']
                            
                                        if !has_key(self._cachedBalloons, buf)
                                            let self._cachedBalloons[buf] = {}
                                        endif
                            
                                        if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
                                            let self._cachedBalloons[buf][e['lnum']] = e['text']
                                        endif
                                    endfor
                                endif
                            
                                return get(self._cachedBalloons, bufnr(''), {})

FUNCTION  59()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedErrors')
                                    let self._cachedErrors = self.filter({'type': 'E'})
                                endif
                                return self._cachedErrors

FUNCTION  60()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedWarnings')
                                    let self._cachedWarnings = self.filter({'type': 'W'})
                                endif
                                return self._cachedWarnings

FUNCTION  61()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return !self.isEmpty()

FUNCTION  62()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedMessages')
                                    let self._cachedMessages = {}
                            
                                    let errors = self.errors() + self.warnings()
                                    for e in errors
                                        let b = e['bufnr']
                                        let l = e['lnum']
                            
                                        if !has_key(self._cachedMessages, b)
                                            let self._cachedMessages[b] = {}
                                        endif
                            
                                        if !has_key(self._cachedMessages[b], l)
                                            let self._cachedMessages[b][l] = [e]
                                        elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
                                    endfor
                            
                                    if self._columns
                                        if !self._sorted
                                            for b in keys(self._cachedMessages)
                                                for l in keys(self._cachedMessages[b])
                                                    if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
                                                endfor
                                            endfor
                                        endif
                            
                                        for b in keys(self._cachedMessages)
                                            for l in keys(self._cachedMessages[b])
                                                call s:_remove_shadowed_items(self._cachedMessages[b][l])
                                            endfor
                                        endfor
                                    endif
                                endif
                            
                                return get(self._cachedMessages, a:buf, {})

FUNCTION  63()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
                                let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                                return filter(copy(self._rawLoclist), filter)

FUNCTION  64()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = 0
                                endif
                                let replace = g:syntastic_reuse_loc_lists && w:syntastic_loclist_set
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
                                call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
                                let w:syntastic_loclist_set = 1

FUNCTION  65()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
                                call self.setloclist()
                            
                                if !self.isEmpty()
                                    let num = winnr()
                                    execute 'lopen ' . syntastic#util#var('loc_list_height')
                                    if num != winnr()
                                        execute num . 'wincmd w'
                                    endif
                            
                                    " try to find the loclist window and set w:quickfix_title
                                    let errors = getloclist(0)
                                    for buf in tabpagebuflist()
                                        if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
                                            let win = bufwinnr(buf)
                                            let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
                                            if strpart(title, 0, 16) ==# ':SyntasticCheck ' || ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
                                                call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
                                                call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  66()
Called 1 time
Total time:   0.000046
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000004     if !exists('s:SyntasticModeMapInstance')
    1              0.000007         let s:SyntasticModeMapInstance = copy(self)
    1   0.000030   0.000005         call s:SyntasticModeMapInstance.synch()
    1              0.000001     endif
                            
    1              0.000003     return s:SyntasticModeMapInstance

FUNCTION  67()
Called 17 times
Total time:   0.001224
 Self time:   0.001224

count  total (s)   self (s)
   17              0.000162     if exists('g:syntastic_mode_map')
    1              0.000017         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
    1              0.000018         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
    1              0.000015         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    1              0.000004     else
   16              0.000137         let self._mode = 'active'
   16              0.000111         let self._activeFiletypes = []
   16              0.000087         let self._passiveFiletypes = []
   16              0.000047     endif

FUNCTION  68()
Called 16 times
Total time:   0.001796
 Self time:   0.001106

count  total (s)   self (s)
   16              0.000411     let fts = split(a:filetype, '\m\.')
                            
   16   0.000384   0.000216     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
   16   0.000754   0.000232         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  69()
Called 16 times
Total time:   0.002641
 Self time:   0.000845

count  total (s)   self (s)
   16              0.000226     let local_mode = get(b:, 'syntastic_mode', '')
   16              0.000149     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
   16   0.002073   0.000277     return self.allowsAutoChecking(&filetype)

FUNCTION  syntastic#util#rmrf()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " try to make sure we don't delete directories we didn't create
                                if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
                                if  getftype(a:what) ==# 'dir'
                                    if !exists('s:rmrf')
                                        let s:rmrf = has('unix') || has('mac') ? 'rm -rf' : has('win32') || has('win64') ? 'rmdir /S /Q' : has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
                                    endif
                            
                                    if s:rmrf !=# ''
                                        silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
                                    else
                                        call s:_rmrf(a:what)
                                    endif
                                else
                                    silent! call delete(a:what)
                                endif

FUNCTION  <SNR>57__is_same_index()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif

FUNCTION  70()
Called 16 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   16              0.000141     return self._mode ==# 'passive'

FUNCTION  71()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call self.synch()
                            
                                if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
                                    let self._mode = 'active'
                                endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
                                if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
                                let g:syntastic_mode_map['mode'] = self._mode

FUNCTION  72()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echo 'Syntastic: ' . self._mode . ' mode enabled'

FUNCTION  73()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echomsg 'Syntastic version: ' . g:_SYNTASTIC_VERSION . ' (Vim ' . v:version . ', ' . g:_SYNTASTIC_UNAME . ')'
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                echomsg 'Info for filetype: ' . type
                            
                                call self.synch()
                                echomsg 'Global mode: ' . self._mode
                                if self._mode ==# 'active'
                                    if len(self._passiveFiletypes)
                                        let plural = len(self._passiveFiletypes) != 1 ? 's' : ''
                                        echomsg 'Passive filetype' . plural . ': ' . join(sort(copy(self._passiveFiletypes)))
                                    endif
                                else
                                    if len(self._activeFiletypes)
                                        let plural = len(self._activeFiletypes) != 1 ? 's' : ''
                                        echomsg 'Active filetype' . plural . ': ' . join(sort(copy(self._activeFiletypes)))
                                    endif
                                endif
                                echomsg 'Filetype ' . type . ' is ' . (self.allowsAutoChecking(type) ? 'active' : 'passive')
                            
                                if !len(a:filetypes)
                                    if exists('b:syntastic_mode') && (b:syntastic_mode ==# 'active' || b:syntastic_mode ==# 'passive')
                                        echomsg 'Local mode: ' . b:syntastic_mode
                                    endif
                            
                                    echomsg 'The current file will ' . (self.doAutoChecking() ? '' : 'not ') . 'be checked automatically'
                                endif

FUNCTION  74()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))

FUNCTION  75()
Called 16 times
Total time:   0.000522
 Self time:   0.000522

count  total (s)   self (s)
   16              0.000496     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  76()
Called 1 time
Total time:   0.000398
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000004     if !exists('s:SyntasticNotifiersInstance')
    1              0.000006         let s:SyntasticNotifiersInstance = copy(self)
    1   0.000383   0.000006         call s:SyntasticNotifiersInstance._initNotifiers()
    1              0.000001     endif
                            
    1              0.000002     return s:SyntasticNotifiersInstance

FUNCTION  77()
Called 19 times
Total time:   0.040559
 Self time:   0.015976

count  total (s)   self (s)
   19   0.000479   0.000300     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
   19   0.000821   0.000300     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
  114              0.000570     for type in self._enabled_types
   95              0.003144         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   95   0.005448   0.002486         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   76              0.000797             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
   19              0.000264                 if !exists('b:syntastic_private_' . type . '_stamp')
    3              0.000017                     let b:syntastic_private_{type}_stamp = []
    3              0.000004                 endif
   19   0.002285   0.000439                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
   19   0.007516   0.000335                     call self._notifier[type].refresh(a:loclist)
   19   0.001579   0.000467                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
   19              0.000080                 endif
   19              0.000045             else
   57   0.011645   0.000863                 call self._notifier[type].refresh(a:loclist)
   57              0.000150             endif
   76              0.000169         endif
   95              0.000256     endfor

FUNCTION  78()
Called 16 times
Total time:   0.013447
 Self time:   0.009281

count  total (s)   self (s)
   16   0.000687   0.000267     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   96              0.000479     for type in self._enabled_types
   80              0.002750         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   80              0.001090         if has_key(g:{class}, 'reset')
   48   0.004611   0.000865             call self._notifier[type].reset(a:loclist)
   48              0.000129         endif
                            
                                    " also reset stamps
   80              0.000827         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
   32              0.000446             let b:syntastic_private_{type}_stamp = []
   32              0.000084         endif
   80              0.000218     endfor

FUNCTION  79()
Called 1 time
Total time:   0.000377
 Self time:   0.000167

count  total (s)   self (s)
    1              0.000005     let self._notifier = {}
    6              0.000013     for type in s:_NOTIFIER_TYPES
    5              0.000078         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000257   0.000047         let self._notifier[type] = g:{class}.New()
    5              0.000007     endfor
                            
    1              0.000006     let self._enabled_types = copy(s:_NOTIFIER_TYPES)

FUNCTION  <SNR>83__format_variable()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let vals = []
                                if exists('g:syntastic_' . a:name)
                                    call add(vals, 'g:syntastic_' . a:name . ' = ' . strtrans(string(g:syntastic_{a:name})))
                                endif
                                if exists('b:syntastic_' . a:name)
                                    call add(vals, 'b:syntastic_' . a:name . ' = ' . strtrans(string(b:syntastic_{a:name})))
                                endif
                            
                                return join(vals, ', ')

FUNCTION  <SNR>56__isAvailableDefault()
Called 2 times
Total time:   0.000354
 Self time:   0.000343

count  total (s)   self (s)
    2   0.000351   0.000340     return executable(self.getExec())

FUNCTION  syntastic#log#deprecationWarn()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif

FUNCTION  80()
Called 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000038     if !exists('s:SyntasticRegistryInstance')
    1              0.000010         let s:SyntasticRegistryInstance = copy(self)
    1              0.000004         let s:SyntasticRegistryInstance._checkerMap = {}
    1              0.000002     endif
                            
    3              0.000017     return s:SyntasticRegistryInstance

FUNCTION  81()
Called 2 times
Total time:   0.001353
 Self time:   0.000303

count  total (s)   self (s)
    2   0.000149   0.000049     let registry = g:SyntasticRegistry.Instance()
                            
    2              0.000021     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
    2   0.000733   0.000049         let checker = g:SyntasticChecker.New(a:args)
    2              0.000007     endif
    2   0.000307   0.000041     call registry._registerChecker(checker)

FUNCTION  82()
Called 16 times
Total time:   0.013220
 Self time:   0.002373

count  total (s)   self (s)
   16   0.001176   0.000311     let ft = s:_normalise_filetype(a:ftalias)
   16   0.009111   0.000244     call self._loadCheckersFor(ft)
                            
   16              0.000160     let checkers_map = self._checkerMap[ft]
   16              0.000107     if empty(checkers_map)
                                    return []
                                endif
                            
   16   0.000832   0.000222     call self._checkDeprecation(ft)
                            
   16              0.000600     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, 0)
                            
   16   0.000967   0.000462     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  83()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isAvailable()')

FUNCTION  84()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isDisabled() && v:val.isAvailable()')

FUNCTION  85()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let types = keys(s:_DEFAULT_CHECKERS)
                            
                                call extend(types, keys(s:_DEFAULT_FILETYPE_MAP))
                            
                                if exists('g:syntastic_filetype_map')
                                    call extend(types, keys(g:syntastic_filetype_map))
                                endif
                            
                                if exists('g:syntastic_extra_filetypes') && type(g:syntastic_extra_filetypes) == type([])
                                    call extend(types, g:syntastic_extra_filetypes)
                                endif
                            
                                return syntastic#util#unique(types)

FUNCTION  86()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft)
                                return keys(filter( copy(self._checkerMap[ft]), 'v:val.isAvailable()' ))

FUNCTION  87()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ft_list = syntastic#util#unique(map( copy(a:ftalias_list), 's:_normalise_filetype(v:val)' ))
                                if len(ft_list) != 1
                                    let available = []
                                    let active = []
                                    let disabled = []
                            
                                    for ft in ft_list
                                        call extend(available, map( self.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                        call extend(active, map( self.getCheckersAvailable(ft, []), 'ft . "/" . v:val.getName()' ))
                                        call extend(disabled, map( self.getCheckersDisabled(ft, []), 'ft . "/" . v:val.getName()' ))
                                    endfor
                                else
                                    let ft = ft_list[0]
                                    let available = self.getNamesOfAvailableCheckers(ft)
                                    let active = map(self.getCheckersAvailable(ft, []), 'v:val.getName()')
                                    let disabled = map(self.getCheckersDisabled(ft, []), 'v:val.getName()')
                                endif
                            
                                let cnt = len(available)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(sort(available)) : '-'
                                echomsg 'Available checker' . plural . ': ' . cklist
                            
                                let cnt = len(active)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(active) : '-'
                                echomsg 'Currently enabled checker' . plural . ': ' . cklist
                            
                                let cnt = len(disabled)
                                let plural = cnt != 1 ? 's' : ''
                                if len(disabled)
                                    let cklist = join(sort(disabled))
                                    echomsg 'Checker' . plural . ' disabled for security reasons: ' . cklist
                                endif
                            
                                " Eclim feels entitled to mess with syntastic's variables {{{3
                                if exists(':EclimValidate') && get(g:, 'EclimFileTypeValidate', 1)
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_eclim(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by Eclim'
                                    endif
                                endif
                                " }}}3
                            
                                " So does YouCompleteMe {{{3
                                if exists('g:loaded_youcompleteme') && get(g:, 'ycm_show_diagnostics_ui', get(g:, 'ycm_register_as_syntastic_checker', 1))
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_ycm(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by YouCompleteMe'
                                    endif
                                endif
                                " }}}3

FUNCTION  88()
Called 2 times
Total time:   0.000266
 Self time:   0.000228

count  total (s)   self (s)
    2   0.000056   0.000037     let ft = a:checker.getFiletype()
    2              0.000024     if !has_key(self._checkerMap, ft)
    2              0.000024         let self._checkerMap[ft] = {}
    2              0.000008     endif
                            
    2   0.000054   0.000035     let name = a:checker.getName()
    2              0.000027     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
    2              0.000029     let self._checkerMap[ft][name] = a:checker

FUNCTION  89()
Called 16 times
Total time:   0.000505
 Self time:   0.000505

count  total (s)   self (s)
   16              0.000478     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  syntastic#util#system()
Called 1 time
Total time:   0.010623
 Self time:   0.000211

count  total (s)   self (s)
    1              0.000004     let old_shell = &shell
    1              0.000004     let old_lc_messages = $LC_MESSAGES
    1              0.000003     let old_lc_all = $LC_ALL
                            
    1   0.000023   0.000010     let &shell = syntastic#util#var('shell')
    1              0.000007     let $LC_MESSAGES = 'C'
    1              0.000005     let $LC_ALL = ''
                            
    1   0.010531   0.000132     let out = system(a:command)
                            
    1              0.000018     let $LC_ALL = old_lc_all
    1              0.000008     let $LC_MESSAGES = old_lc_messages
                            
    1              0.000009     let &shell = old_shell
                            
    1              0.000004     return out

FUNCTION  syntastic#log#warn()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echohl WarningMsg
                                echomsg 'syntastic: warning: ' . a:msg
                                echohl None

FUNCTION  syntastic#log#debugShowVariables()
Called 32 times
Total time:   0.001007
 Self time:   0.000673

count  total (s)   self (s)
   32   0.000828   0.000494     if !s:_isDebugEnabled(a:level)
   32              0.000093         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>64_CompleteFiletypes()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return join(s:registry.getKnownFiletypes(), "\n")

FUNCTION  90()
Called 16 times
Total time:   0.008867
 Self time:   0.006685

count  total (s)   self (s)
   16              0.000171     if has_key(self._checkerMap, a:filetype)
   14              0.000041         return
                                endif
                            
    2   0.008535   0.006353     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    2              0.000031     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  91()
Called 16 times
Total time:   0.000610
 Self time:   0.000610

count  total (s)   self (s)
   16              0.000282     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  92()
Called 1 time
Total time:   0.000126
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007     let newObj = copy(self)
                            
    1              0.000002     if !s:setup_done
    1   0.000106   0.000005         call self._setup()
    1              0.000003         let s:setup_done = 1
    1              0.000003         lockvar s:setup_done
    1              0.000001     endif
                            
    1              0.000002     return newObj

FUNCTION  93()
Called 38 times
Total time:   0.001917
 Self time:   0.000828

count  total (s)   self (s)
   38   0.001863   0.000774     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  94()
Called 19 times
Total time:   0.007181
 Self time:   0.001548

count  total (s)   self (s)
   19   0.000807   0.000295     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
   19   0.000840   0.000340     let old_signs = copy(self._bufSignIds())
   19   0.001124   0.000200     if self.enabled()
   19   0.003079   0.000284         call self._signErrors(a:loclist)
   19              0.000046     endif
   19   0.001193   0.000291     call self._removeSigns(old_signs)

FUNCTION  95()
Called 1 time
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    1              0.000005     if has('signs')
    1              0.000005         if !hlexists('SyntasticErrorSign')
    1              0.000008             highlight link SyntasticErrorSign error
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticWarningSign')
    1              0.000003             highlight link SyntasticWarningSign todo
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorSign')
    1              0.000003             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleWarningSign')
    1              0.000003             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorLine')
    1              0.000004             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000001         endif
    1              0.000003         if !hlexists('SyntasticStyleWarningLine')
    1              0.000003             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000000         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000014         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000009         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000009         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000008         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  96()
Called 19 times
Total time:   0.002795
 Self time:   0.002622

count  total (s)   self (s)
   19              0.000152     let loclist = a:loclist
   19   0.000393   0.000220     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  97()
Called 19 times
Total time:   0.000902
 Self time:   0.000902

count  total (s)   self (s)
   19              0.000183     if has('signs')
   19              0.000227         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
   19              0.000046     endif

FUNCTION  98()
Called 19 times
Total time:   0.000500
 Self time:   0.000500

count  total (s)   self (s)
   19              0.000206     if !exists('b:syntastic_private_sign_ids')
    3              0.000010         let b:syntastic_private_sign_ids = []
    3              0.000004     endif
   19              0.000099     return b:syntastic_private_sign_ids

FUNCTION  <SNR>64_BufReadPostHook()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003     if g:syntastic_check_on_open
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
                                    call s:UpdateErrors(1, [])
                                endif

FUNCTION  syntastic#util#setWids()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for tab in range(1, tabpagenr('$'))
                                    for win in range(1, tabpagewinnr(tab, '$'))
                                        if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
                                            call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
                                            let s:_wid_pool += 1
                                        endif
                                    endfor
                                endfor

FUNCTION  syntastic#util#isRunningWindows()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000010     return has('win16') || has('win32') || has('win64')

FUNCTION  syntastic#util#compareLexi()
Called 16 times
Total time:   0.001147
 Self time:   0.001147

count  total (s)   self (s)
   16              0.000364     for idx in range(max([len(a:a), len(a:b)]))
   16              0.000243         let a_element = str2nr(get(a:a, idx, 0))
   16              0.000226         let b_element = str2nr(get(a:b, idx, 0))
   16              0.000107         if a_element != b_element
   16              0.000111             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  SyntasticReset()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))

FUNCTION  <SNR>64_BufWritePostHook()
Called 16 times
Total time:   0.121543
 Self time:   0.001635

count  total (s)   self (s)
   16   0.002094   0.001196     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
   16   0.119362   0.000352     call s:UpdateErrors(1, [])

FUNCTION  <SNR>64__ignore_file()
Called 32 times
Total time:   0.002198
 Self time:   0.002198

count  total (s)   self (s)
   32              0.001141     let fname = fnamemodify(a:filename, ':p')
   32              0.000332     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
   32              0.000101     return 0

FUNCTION  <SNR>83__is_modified()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:option_defaults')
                                    let s:option_defaults = {}
                                endif
                                if !has_key(s:option_defaults, a:name)
                                    let opt_save = eval('&' . a:name)
                                    execute 'set ' . a:name . '&'
                                    let s:option_defaults[a:name] = eval('&' . a:name)
                                    execute 'let &' . a:name . ' = ' . string(opt_save)
                                endif
                            
                                return s:option_defaults[a:name] !=# eval('&' . a:name)

FUNCTION  <SNR>64__explain_skip()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if empty(a:filetypes) && s:_skip_file()
                                    let why = []
                                    let fname = expand('%', 1)
                            
                                    if s:_is_quitting(bufnr('%'))
                                        call add(why, 'quitting buffer')
                                    endif
                                    if get(b:, 'syntastic_skip_checks', 0)
                                        call add(why, 'b:syntastic_skip_checks set')
                                    endif
                                    if &buftype !=# ''
                                        call add(why, 'buftype = ' . string(&buftype))
                                    endif
                                    if !filereadable(fname)
                                        call add(why, 'file not readable / not local')
                                    endif
                                    if getwinvar(0, '&diff')
                                        call add(why, 'diff mode')
                                    endif
                                    if s:_ignore_file(fname)
                                        call add(why, 'filename matching g:syntastic_ignore_files')
                                    endif
                                    if fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                        call add(why, 'extension matching g:syntastic_ignore_extensions')
                                    endif
                            
                                    echomsg 'The current file will not be checked (' . join(why, ', ') . ')'
                                endif

FUNCTION  syntastic#log#ndebug()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#error(a:title)
                                if type(a:messages) == type([])
                                    for msg in a:messages
                                        echomsg msg
                                    endfor
                                else
                                    echomsg a:messages
                                endif

FUNCTION  <SNR>59__set_screen_column()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !has_key(a:item, 'scol')
                                    let col = get(a:item, 'col', 0)
                                    if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
                                        let a:item['scol'] = col
                                    endif
                                endif

FUNCTION  SyntasticLoclistHide()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
                                silent! lclose

FUNCTION  <SNR>57__find_index()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let max = len(a:messages) - 1
                                if max == 0
                                    return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max

FUNCTION  syntastic#util#DevNull()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if syntastic#util#isRunningWindows()
                                    return 'NUL'
                                endif
                                return '/dev/null'

FUNCTION  syntastic#util#wformat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:format ==# ''
                                    return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out

FUNCTION  syntastic#util#bufIsActive()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
                                let buf = str2nr(a:buffer)
                            
                                if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
                                for tab in range(1, tabpagenr('$'))
                                    if index(tabpagebuflist(tab), buf) >= 0
                                        return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  SyntasticCheck()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:UpdateErrors(0, a:000)
                                call syntastic#util#redraw(g:syntastic_full_redraws)

FUNCTION  <SNR>62__disabled_by_ycm()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return index(s:_YCM_TYPES, a:filetype) >= 0

FUNCTION  <SNR>59__remove_shadowed_items()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " keep only the first message at a given column
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile

FUNCTION  SyntasticBalloonsExprNotifier()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('b:syntastic_private_balloons')
                                    return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')

FUNCTION  <SNR>62__normalise_filetype()
Called 16 times
Total time:   0.000865
 Self time:   0.000865

count  total (s)   self (s)
   16              0.000247     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
   16              0.000187     let ft = get(g:syntastic_filetype_map, ft, ft)
   16              0.000301     let ft = substitute(ft, '\m-', '_', 'g')
   16              0.000071     return ft

FUNCTION  <SNR>59__compare_error_items_by_columns()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif

FUNCTION  syntastic#util#screenWidth()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let chunks = split(a:str, "\t", 1)
                                let width = s:_width(chunks[-1])
                                for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
                                return width

FUNCTION  syntastic#util#parseVersion()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')

FUNCTION  SyntasticToggleMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:modemap.toggleMode()
                                call s:ClearCache()
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                                call s:modemap.echoMode()

FUNCTION  <SNR>83__logRedirect()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('g:syntastic_debug_file')
                                    if a:on
                                        try
                                            execute 'redir >> ' . fnameescape(expand(g:syntastic_debug_file, 1))
                                        catch /\m^Vim\%((\a\+)\)\=:/
                                            silent! redir END
                                            unlet g:syntastic_debug_file
                                        endtry
                                    else
                                        silent! redir END
                                    endif
                                endif

FUNCTION  syntastic#util#CygwinPath()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return substitute(syntastic#util#system('cygpath -m ' . syntastic#util#shescape(a:path)), "\n", '', 'g')

FUNCTION  syntastic#log#debugDump()
Called 16 times
Total time:   0.000413
 Self time:   0.000273

count  total (s)   self (s)
   16   0.000335   0.000195     if !s:_isDebugEnabled(a:level)
   16              0.000044         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>83__isDebugEnabled_smart()
Called 339 times
Total time:   0.003475
 Self time:   0.003475

count  total (s)   self (s)
  339              0.002925     return and(g:syntastic_debug, a:level)

FUNCTION  syntastic#util#wideMsg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
                                let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
                                let msg = strpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                call syntastic#util#redraw(0)
                            
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd

FUNCTION  43()
Called 79 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
   79              0.000574     return empty(self._rawLoclist)

FUNCTION  <SNR>64_QuitPreHook()
Called 1 time
Total time:   0.000407
 Self time:   0.000287

count  total (s)   self (s)
    1              0.000137     let buf = bufnr(fnameescape(a:fname))
    1   0.000137   0.000066     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000074   0.000025     if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
                                endif
                            
    1              0.000011     if get(w:, 'syntastic_loclist_set', 0)
                                    call SyntasticLoclistHide()
                                endif

FUNCTION  <SNR>83__isDebugEnabled_dumb()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " poor man's bit test for bit N, assuming a:level == 2**N
                                return (g:syntastic_debug / a:level) % 2

FUNCTION  SyntasticMake()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
                                let old_local_errorformat = &l:errorformat
                                let old_errorformat = &errorformat
                                let old_cwd = getcwd()
                                " }}}3
                            
                                if has_key(a:options, 'errorformat')
                                    let &errorformat = a:options['errorformat']
                                endif
                            
                                if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
                                let env_save = {}
                                if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
                                let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
                                if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
                                let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
                                if !bailout
                                    if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
                                    lgetexpr err_lines
                            
                                    let errors = deepcopy(getloclist(0))
                            
                                    if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
                                    try
                                        silent lolder
                                    catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
                                else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
                                let &errorformat = old_errorformat
                                let &l:errorformat = old_local_errorformat
                                " }}}3
                            
                                if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
                                if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
                                if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
                                if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
                                if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
                                return errors

FUNCTION  syntastic#util#unique()
Called 32 times
Total time:   0.002990
 Self time:   0.002990

count  total (s)   self (s)
   32              0.000254     let seen = {}
   32              0.000241     let uniques = []
   64              0.000336     for e in a:list
   32              0.000313         if !has_key(seen, e)
   32              0.000328             let seen[e] = 1
   32              0.000328             call add(uniques, e)
   32              0.000098         endif
   32              0.000090     endfor
   32              0.000146     return uniques

FUNCTION  SyntasticErrors()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call g:SyntasticLoclist.current().show()

FUNCTION  <SNR>64_CompleteCheckerName()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let checker_names = []
                                for ft in s:_resolve_filetypes([])
                                    call extend(checker_names, s:registry.getNamesOfAvailableCheckers(ft))
                                endfor
                                return join(checker_names, "\n")

FUNCTION  syntastic#util#var()
Called 199 times
Total time:   0.005760
 Self time:   0.005760

count  total (s)   self (s)
  199              0.005398     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  45()
Called 19 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
   19              0.000162     return copy(self._rawLoclist)

FUNCTION  syntastic#util#shexpand()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  syntastic#util#findGlobInParent()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let here = fnamemodify(a:where, ':p')
                            
                                let root = syntastic#util#Slash()
                                if syntastic#util#isRunningWindows() && here[1] ==# ':'
                                    " The drive letter is an ever-green source of fun.  That's because
                                    " we don't care about running syntastic on Amiga these days. ;)
                                    let root = fnamemodify(root, ':p')
                                    let root = here[0] . root[1:]
                                endif
                            
                                let old = ''
                                while here !=# ''
                                    let p = split(globpath(here, a:what, 1), '\n')
                            
                                    if !empty(p)
                                        return fnamemodify(p[0], ':p')
                                    elseif here ==? root || here ==? old
                                        break
                                    endif
                            
                                    let old = here
                            
                                    " we use ':h:h' rather than ':h' since ':p' adds a trailing '/'
                                    " if 'here' is a directory
                                    let here = fnamemodify(here, ':p:h:h')
                                endwhile
                            
                                return ''

FUNCTION  SyntasticInfo()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:modemap.modeInfo(a:000)
                                call s:registry.echoInfoFor(s:_resolve_filetypes(a:000))
                                call s:_explain_skip(a:000)

FUNCTION  syntastic#util#dictFilter()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
                                try
                                    call filter(a:errors, rules)
                                catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry

FUNCTION  syntastic#util#argsescape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if type(a:opt) == type('') && a:opt !=# ''
                                    return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
                                return []

FUNCTION  SyntasticStatuslineFlag()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  syntastic#log#info()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echomsg 'syntastic: info: ' . a:msg

FUNCTION  <SNR>64_ClearCache()
Called 16 times
Total time:   0.017867
 Self time:   0.001022

count  total (s)   self (s)
   16   0.014361   0.000384     call s:notifiers.reset(g:SyntasticLoclist.current())
   16   0.003473   0.000605     call b:syntastic_loclist.destroy()

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   16   0.121543   0.001635  <SNR>64_BufWritePostHook()
   16   0.119010   0.007148  <SNR>64_UpdateErrors()
   16   0.061774   0.011828  <SNR>64_CacheErrors()
   19   0.040559   0.015976  77()
   16   0.017867   0.001022  <SNR>64_ClearCache()
   16   0.013447   0.009281  78()
   16   0.013220   0.002373  82()
    1   0.010623   0.000211  syntastic#util#system()
   32   0.009829   0.005517  <SNR>64__skip_file()
   16   0.008867   0.006685  90()
  275   0.007989   0.005132  syntastic#log#debug()
   19   0.007181   0.001548  94()
  199   0.005760             syntastic#util#var()
   19   0.005320   0.003186  35()
   16   0.004824   0.001407  55()
   32   0.004058   0.001068  47()
    3   0.004004   0.000457  <SNR>64_BufEnterHook()
   19   0.003644   0.000611  4()
  339   0.003475             <SNR>83__isDebugEnabled_smart()
   32   0.002990             syntastic#util#unique()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   19   0.040559   0.015976  77()
   16   0.061774   0.011828  <SNR>64_CacheErrors()
   16   0.013447   0.009281  78()
   16   0.119010   0.007148  <SNR>64_UpdateErrors()
   16   0.008867   0.006685  90()
  199              0.005760  syntastic#util#var()
   32   0.009829   0.005517  <SNR>64__skip_file()
  275   0.007989   0.005132  syntastic#log#debug()
  339              0.003475  <SNR>83__isDebugEnabled_smart()
   19   0.005320   0.003186  35()
   32              0.002990  syntastic#util#unique()
   19   0.002795   0.002622  96()
   16   0.013220   0.002373  82()
   19              0.002319  39()
   32              0.002198  <SNR>64__ignore_file()
   35              0.002167  syntastic#util#stamp()
   32              0.002114  <SNR>64__is_quitting()
   16   0.121543   0.001635  <SNR>64_BufWritePostHook()
   19   0.007181   0.001548  94()
   16   0.004824   0.001407  55()

